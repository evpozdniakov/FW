<?phpclass Model{	/*	 ->__name__ название модели	 ->__txt_name__ русское название модели	 ->__item__ равно true если текущий экземпляр класса является элементом модели	 ->_input массив значений переданных в конструктор при создании элемента модели	 */	var $ipp=10;	//MODEL	function Model($params_arr_or_str=''){//создает либо объект модели, либо - если есть $params_arr_or_str - элемент модели		//запоминаем атрибуты модели		$this->__name__=strtolower(get_class($this));		$this->__dir__=sprintf('%s/%s', MODELS_DIR, $this->__name__);		$this->__models__=sprintf('%s/_models.php', $this->__dir__);		$this->__views__=sprintf('%s/_views.php', $this->__dir__);		$this->__gif__=sprintf('%s/icon.gif', $this->__dir__);		$this->__png__=sprintf('%s/icon.png', $this->__dir__);		if(empty($params_arr_or_str)){			//для модели views определяем только название родительского класса			$this->model_name=get_parent_class($this);		}else{			//в $params_arr_or_str может содержаться число=id элемента.			//если так, то переделаем $params_arr_or_str,			//превратив его (для унификации) в массив			if(is_numeric($params_arr_or_str)){				$params_arr_or_str=array('id'=>(int)$params_arr_or_str);				//$params_arr_or_str['id']=(int)$params_arr_or_str;			}			/*				конструктор модели может быть вызван				ЛИБО для создания объекта модели, и тогда этот объект будет содержать				информацию о полях в виде объектов классов *Field,				ЛИБО для созадния элемента модели, и тогда объект будет содержать				конкретные значения этих полей				определить для какой цели вызывается конструктор можно по типу				пришедшего параметра: для создания объекта передается строка, для создания				элемента - массив				после недолгих размышлений решил сохранять в $this->_input массив $precedent_values				если элемент модели был создан по id, но после чуть более долгих раздумий решил этого не делать				*/			if(is_array($params_arr_or_str)){				//СОЗДАЕМ ЭЛЕМЕНТ МОДЕЛИ				//получаем объект модели				$obj_model=gmo($this->__name__);				//если id>0 вытаскиваем значения, имеющиеся в БД				$precedent_values=array();				if(true				&& is_array($params_arr_or_str)				&& isset($params_arr_or_str['id'])				&& is_numeric($params_arr_or_str['id'])				&& $params_arr_or_str['id']>0				){					$id=(int)$params_arr_or_str['id'];					$precedent_values=gbi($this->__name__,$id);				}				//перебираем поля объекта				if(is_object($obj_model)){					foreach(get_object_vars($obj_model) as $field_name=>$obj_field){						if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){							$this->$field_name=$obj_field->getModelItemInitValueCommon($params_arr_or_str,$precedent_values);						}					}					//устанавливаем специальное поле, которое необходимо для связи привязанных моделей					//с частями массива $_FILES					if(isset($params_arr_or_str['_relkey'])){						$this->_relkey=$params_arr_or_str['_relkey'];					}				}else{_die('empty array1');}				//запоминаем исходный массив данных				$this->_input=$params_arr_or_str;				/*					раньше было так:					if( $id>0 && (is_numeric($params_arr_or_str['id']) || is_numeric($params_arr_or_str)) ){					//понадобилось дополнить это условие,					//чтобы при создании элемента при передаче формы в _input					//помещались бы не $precedent_values, а $params_arr_or_str					$this->_input=$precedent_values;					}else{					$this->_input=$params_arr_or_str;					}					*/				//устанавливаем флаг, чтобы отличать элемент от НЕэлемента				$this->__item__=true;			}else{				//СОЗДАЕМ ОБЪЕКТ МОДЕЛИ				//в каждую модель добавляем класс PrimaryKeyField				$this->id=new PrimaryKeyField();				$this->ip=new IPField();				$this->mdate=new TimestampField();				//$this->_mdate=new TimestampField();				//$this->_ip=new IPField();				if( !Admin::isASynchroProcess() ){					//запоминаем русское название модели					$this->__txt_name__=$params_arr_or_str;					//запускаем метод init_vars() для определения массива __admin__, отвечающего за					//внешний вид админки модели					$this->init_vars();					//переопределяем переменную $this->ipp					if(isset($this->__admin__['ipp'])){						$this->ipp=$this->__admin__['ipp'];						unset($this->__admin__['ipp']);					}				}			}		}	}	function init(){		//запускаем метод init_fields() в котором происходит создание объектов класса *Field		$this->init_fields();		//перебираем экземпляры класса Field		foreach(get_object_vars($this) as $field_name=>$obj_field){			//_print_r($obj_field);			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				//для каждого объекта Field вызываем его init()				$this->$field_name->init($this->__name__,$field_name);			}		}		// по окончании вызываем метод after_init() усли такой существует		if(method_exists($this,'after_init')){			$this->after_init();		}	}	function objects(){//возвращает экземплар класса ModelManager, который позволяет осуществлять запросы в БД		$obj_modelmanager=new ModelManager($this->__name__);		return $obj_modelmanager;	}	function getSQLdropTable(){//возвращает текст запроса для удаления таблицы модели		$result='drop table if exists `'.$this->__name__.'`;';		return $result;	}	function getSQLcreateTable(){//возвращает текст запроса для создания таблицы модели		$results=array();		foreach(get_object_vars($this) as $field_name=>$obj_field){			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				if( is_a($obj_field,'ManyToManyField') ){					//поля OneToMany и ManyToMany не превносят изменений в таблицу модели					//но используют вспомогательную таблицу					$results[$field_name]=$obj_field->getSQLcreate();				}else{					//для каждого поля вызывается его метод getSQLcreate()					if(!isset($results['main'])){						$results['main']='';					}					$results['main'].=$obj_field->getSQLcreate();				}			}		}		//убираем запятую		if($results['main']!=''){$results['main']=mb_substr(trim($results['main']),0,-1);}		//добавляем create table (...)		$results['main']='create table `'.$this->__name__.'` ('."\r\n".$results['main'].','."\r\n".'primary key (`id`)'."\r\n".');';		return $results;	}	function try2createTable(){//создает таблицу, если та не существует и возвращает true, иначе false (проверка соответствия полей модели и полей таблицы не осуществляется)		$result=false;		if( !$this->checkModelTableExists() ){			$sql=$this->getSQLcreateTable();			$dbq=new DBQ($sql['main']);			$result=true;		}		return $result;	}	function dropCreateTable(){//создает таблицу, если та не существует и возвращает true, иначе false (проверка соответствия полей модели и полей таблицы не осуществляется)		$dbq=new DBQ($this->getSQLdropTable());		$sql=$this->getSQLcreateTable();		$dbq=new DBQ($sql['main']);	}	function checkModelTableExists(){//возвращает true, если таблица модели существует (без проверки соответствия полей)		$result=false;		$dbq=new DBQ('show tables like ?',$this->__name__);		if($dbq->rows==1){			$result=true;		}		return $result;	}	function changeModelsPHP(){//изменяет файл _models.php текущей модели	}	function changeModelsDBtable(){//изменяет (добавляет) таблицу текущей модели в БД		/*		в БД либо есть нужная таблица и она правильная,		либо она есть но неправильная, либо ее нет совсем. наша задача:		1. выяснить есть ли нужная таблица (при необходимости создать)		2. если есть, то проверить каждое поле и при необходимости изменить.		3. сообщить о проделанной работе		*/		//пытаемся создать таблицу		if($this->try2createTable()){			$sql=$this->getSQLcreateTable();			$result['created']=$sql['main'];			//$dbq=new DBQ($this->getSQLdropTable());		}else{			//таблица уже существует, нужно ее проверить			//вытаскиваем информацию по каждому из полей			$db_columns_info=$this->_getModelsTableDbColumnsInfo();			//пробегаемся по все полям модели			foreach(get_object_vars($this) as $field_name=>$obj_field){				if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){					if( is_a($obj_field,'ManyToManyField') ){						//для OneToManyField и ManyToManyField выполняется код,						//создающий вспомогательную таблицу (если ее еще нет)						if($obj_field->try2createTable()){							$result['created'].=$obj_field->getSQLcreate();						}					}else{						//запускаем метод ->repareDbColumn() для каждого из полей						$report=$obj_field->repareDbColumn($db_columns_info);						if($report!=''){							$result['columns'][$field_name]=$report;						}					}				}			}		}		if(isset($result)){			return $result;		}	}	//REL MODELS	function getCoreFields(){		$current_id=$this->getModelItemIdFromGetQuery();		if( $current_id ){			$result='';			//получаем массив объектов полей, которые смотрят на текущую модель			$rel_fields_arr=$this->_getRelFieldsArr();//_print_r($rel_fields_arr);			//перебираем и вызываем для каждого getCoreFieldsHTML			if(is_array($rel_fields_arr)){				foreach($rel_fields_arr as $field){					//в случае, если $field->num_in_admin!==false					if($field->num_in_admin!==false && $field->num_in_admin!='false'){						//обращаемся к модели поля и просим вернуть coreHTML для db_column=$this->id						$field_model_obj=gmo($field->model_name);						//_echo($field->db_column);						$result.=$field_model_obj->getCoreFieldsHTML($field->db_column,$current_id,$field->num_in_admin);					}				}			}			return $result;		}	}	//HTML	function getModelItemsFilter(){		if( isset($this->__admin__['tf']) || isset($this->__admin__['type_filter']) ){			$result='				<form id="typeFilterForm" action="'.DOMAIN_PATH.$_SERVER['REDIRECT_URL'].'" method="post">					<div>						<a class="reset" href="#"></a>						<input type="text" name="tf" value="'.e5c(p2v('tf')).'">					</div>				</form>			';			return $result;		}	}		/**	 * возвращает HTML-код со списком элементов для модели в админке	 * @return string	 */	function getModelItemsListHTML(){		//_echo('call getModelItemsListHTML()','bold');		if($this->userCanSeeModelInAdmin()){			//_print_r('$model_items_data',$model_items_data);			$models_arr=$this->drawModelsArray();			//_print_r('drawModelsArray() $models_arr',$models_arr);			$models_grouppers_arr=$this->drawModelsGrouppersArray($models_arr);			//_print_r('drawModelsGrouppersArray() $models_grouppers_arr',$models_grouppers_arr);			$models_grouppers_arr=$this->setModelsGrouppersArray($models_grouppers_arr);			//_print_r('setModelsGrouppersArray()',$models_grouppers_arr);			$models_elements_tree=$this->drawModelsElementsTree($models_grouppers_arr);			//_print_r('drawModelsElementsTree() $models_elements_tree',$models_elements_tree);			include(FW_DIR.'/classes/templates/model/model_items_tree_list.php');			//если ajax			if(IS_AJAX===true){				ajaxGzip($result);			}		}		//возвращаем результат		//_print_r($model_items_data);exit();		return $result;	}	/**	 * создаем цепочку моделей, которые участвуют в группировке 			 * метод принимает один параметр - название модели (это нужно 			 * для формирования селектбокса). если параметр не передан, 			 * определяем название текущей модели из пути. далее производится 			 * рекурсивный поиск в методе ->drawModelsArrayRec()	 * @param $model_name - название модели	 * @return array	 */	function drawModelsArray($model_name=''){		if(empty($model_name)){			$model_name=$GLOBALS['path'][2];		}		//запускаем рекурсивный поиск цепочки моделей		$models_arr=array($model_name);		if(!p2v('tf')){			$models_arr=$this->drawModelsArrayRec($model_name,$models_arr);			$models_arr=array_reverse($models_arr);			//_log('$models_arr',$models_arr);		}		// _print_r('$models_arr',$models_arr);		return $models_arr;	}	/**	 * вспомогательный рекурсивный метод, вызывается в $this->drawModelsArray()	 * @param $model_name название модели	 * @param $models_arr массив с промежуточной цепочкой моделей 	 * @return array	 */	function drawModelsArrayRec($model_name,$models_arr){		//_print_r('$model_name is ['.$model_name.'], $models_arr is',$models_arr);		//объект модели		$model_obj=gmo($model_name);		//группираторы модели		$model_grouppers=$model_obj->__admin__['group'];		if(!empty($model_grouppers)){			//_print_r('$model_grouppers are ['.$model_grouppers.']');			//первый группиратор (только он может быть полем типа ForeignKeyField			//ОКАЗЫВАЕТСЯ НЕ ТОЛЬКО ОН МОЖЕТ ИМЕТЬ ТИП FOREIGNKEYFIELD!!!!!!!!!!!			$grouppers=explode(',',$model_grouppers);			$grouppers=array_reverse($grouppers);			foreach($grouppers as $groupper){				$groupper=trim($groupper);				if(!empty($groupper)){					$groupper=$model_obj->$groupper;					if(!is_object($groupper) || !is_subclass_of($groupper,'Field')){						_die('группиратор «'.$groupper.'» модели «'.$model_obj->__name__.'» не является наследником класса Field');					}					if(is_a($groupper,'ForeignKeyField')){						$rel_model_name=$groupper->getRelModelName();						$models_arr[]=$rel_model_name;						$models_arr=$this->drawModelsArrayRec($rel_model_name,$models_arr);					}				}			}		}		return $models_arr;	}		/**	 * метод получает цепочку моделей, участвующих в группировке	 * и возвращает массив, ключами которого являются названия моделей	 * а значениями - массивы группираторов:	 * array(	 * 	'users'=>array(),	 * 	'folders'=>array('users_id'=>'ForeignKeyField','parent'=>'TreeField'),	 *	'notes'=>array('folders_id'=>'ForeignKeyField')	 * )	 * @param $models_arr array	 * @return array	 */	function drawModelsGrouppersArray($models_arr){		$models_grouppers_arr=array();		foreach($models_arr as $model_name){			$models_grouppers_arr[$model_name]=array();			if(p2v('tf')){return $models_grouppers_arr;}			$model_obj=gmo($model_name);			$grouppers=$model_obj->__admin__['group'];			if(!empty($grouppers)){				$grouppers=explode(',',$grouppers);				if(count($grouppers)>0){					foreach($grouppers as $groupper_name){						$groupper_obj=$model_obj->$groupper_name;						if(!is_subclass_of($groupper_obj,'Field')){							_die('объект, получаемый из группиратора «'.$groupper_name.'» модели «'.$model_name.'» не является наследником класса Field');						}						$models_grouppers_arr[$model_name][$groupper_name]=get_class($groupper_obj);					}				}			}		}		// _print_r('models_grouppers_arr',$models_grouppers_arr);		return $models_grouppers_arr;	}	/**	 * метод определяет значения группираторов, основываясь на get-параметрах 	 * получает на входе массив $models_grouppers_arr, дополняет его и возвращает:	 * array (	 * 	'catstructure' => array ('parent' => 'TreeField,0,12,14',),	 * 	'catproducts' => array ('catstructure_id' => 'ForeignKeyField,16','domain' => 'CharField,legkaya_promyshlennost',),	 * 	'catprices' => array ('catproducts_id' => 'ForeignKeyField,','calibration' => 'IntField,35','calibration' => 'DateField,2009-08-07',)	 * )	 * @param $models_grouppers_arr array	 * @return array	 */	function setModelsGrouppersArray($models_grouppers_arr){		//_log('setModelsGrouppersArray');		//в массиве $db_lookup будем хранить элементы различных моделей, взятые по id		$db_lookup=array();		//возможно на текущей странице показывается конечный элемент		//если да, то помещаем его в $db_lookup		$current_model_name=$GLOBALS['path'][2];		$current_id=$_GET[$current_model_name]['id'];		if(!empty($current_id)){			$db_lookup[$current_model_name]=gbi($current_model_name,$current_id);		}		//переворачиваем входящий массив		$models_grouppers_arr=array_reverse($models_grouppers_arr);		//проходим по цепочке моделей из конца в начало		foreach($models_grouppers_arr as $model_name=>$grouppers_arr){			if(count($grouppers_arr)>0){				//переворачиваем массив группираторов				$grouppers_arr=array_reverse($grouppers_arr);				//проходим по нему от последнего к первому				//цель данного метода - установить значения группираторам				foreach($grouppers_arr as $groupper_name=>$groupper_class){					//в первую очередь проверяем задано ли значение с помощью get-параметра					$get=$_GET[$model_name][$groupper_name];					if($get!=''){						$value=$get;						//возможно значение имеется в массиве $db_lookup					}elseif(strtolower($groupper_class)=='treefield' && isset($value)){						//не переопределяем $value					}elseif(is_array($db_lookup[$model_name])){						$value=$db_lookup[$model_name][$groupper_name];					}					//если это группиратор типа  TreeField, то вытаскиваем из БД значения всех родителей					if(strtolower($groupper_class)=='treefield'){						if(isset($value) && $value!=''){							$id=$value;							$parents=array($id);							while(true && $max_loop++<999){								$dbq=new DBQ('select `@` from `@` where id=?',$groupper_name,$model_name,$id);								if($dbq->rows==0){break;}								$id=$dbq->item;								$parents[]=$id;							}							//переворачиваем родителей и объединяем в строку							$parents=array_reverse($parents);							$parents=implode(',',$parents);						}else{							$parents='0';						}						//переопределяем результирующий массив						$grouppers_arr[$groupper_name]=$groupper_class.','.$parents;					}elseif(isset($value) && $value!=''){						// _print_r('$groupper_class = '.$groupper_class);						//значение имеется, помещаем его в результирующий массив						if(strtolower($groupper_class)=='foreignkeyfield'){							//_print_r('$value1',$value);							if($_GET[$model_name][$groupper_name]){								$value=$_GET[$model_name][$groupper_name];							}else{								$value=$db_lookup[$model_name][$groupper_name];							}							//_print_r('$value2',$value);							$grouppers_arr[$groupper_name]=$groupper_class.','.$value;							//$value=$_GET[$model_name][$groupper_name];							//если это группиратор типа  ForeignKeyField, то вытаскиваем из БД							//другие значения элемента и помещаем их в $db_lookup							$model_obj=gmo($model_name);							$groupper_obj=$model_obj->$groupper_name;							unset($model_obj);							$rel_model_name=$groupper_obj->getRelModelName();							unset($groupper_obj);							$rel_model_name_item=gbi($rel_model_name,$value);							$db_lookup[$rel_model_name]=$rel_model_name_item;							//если это группиратор типа  DateField или DateTimeField, то						}elseif(strtolower($groupper_class)=='datefield' || strtolower($groupper_class)=='datetimefield' || strtolower($groupper_class)=='timestampfield'){							$grouppers_arr[$groupper_name]=$groupper_class.','.$value;							//значение может иметь вид y2009 или y2009-m05							//вытаскиваем значение поля из $value							$date_arr=explode('-',$value);							$grouppers_arr[$groupper_name]=$groupper_class.','.$date_arr[0].'-'.$date_arr[1];						}elseif(strtolower($groupper_class)=='charfield' || strtolower($groupper_class)=='intfield'){							$grouppers_arr[$groupper_name]=$groupper_class.','.$value;							//если это группиратор типа  CharField или IntField, то вытаскиваем из БД							//другие значения элемента и помещаем их в $db_lookup							//но лишь в том случае, если этот $db_lookup еще не определен							if(!isset($db_lookup[$model_name])){								$model_obj=gmo($model_name);								$items=$model_obj->ga(array(									'fields'=>'*',//список полей которые нужно вытащить через запятую 'id,name,body'									'filter'=>e5csql('`@`=?',$groupper_name,$value),//массив типа array('select'=>'id,body', 'where'=>'parent>?', 'params'=>$parent)									'_slice'=>'0,1',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)								));								$db_lookup[$model_name]=$items[0];							}						}					}				}				//меняем порядок группираторов на первоначальный				$grouppers_arr=array_reverse($grouppers_arr);				$models_grouppers_arr[$model_name]=$grouppers_arr;			}		}		//меняем порядок моделей на первоначальный		$models_grouppers_arr=array_reverse($models_grouppers_arr);		// _print_r('$models_grouppers_arr',$models_grouppers_arr);		return $models_grouppers_arr;	}	/**	 * данный метод получает массив с группираторами моделей и их значениями,	 * анализирует его, создает и возвращает дерево элементов моделей вида:	 * array(	 * 	1=>array(type=>'folder_closed',title=>'Азия',url=>'/admin/cities/edit/?continents[id]=1'),	 * 	2=>array(type=>'folder_opened',title=>'Европа',url=>'/admin/cities/edit/?continents[id]=2',children=>array(	 * 		1=>array(type=>'folder_closed',title=>'Австрия',url=>'/admin/cities/edit/?countries[id]=1'),	 * 		2=>array(type=>'folder_closed',title=>'Албания',url=>'/admin/cities/edit/?countries[id]=2'),	 * 		3=>array(type=>'folder_closed',title=>'Бельгия',url=>'/admin/cities/edit/?countries[id]=3'),	 * 		4=>array(type=>'folder_opened',title=>'Великобритания',url=>'/admin/cities/edit/?countries[id]=3',children=>array(	 * 			1=>array(type=>'element',title=>'Wombourne',url=>'/admin/cities/edit/?cities[id]=1'),	 * 			2=>array(type=>'element_current',title=>'Wombwell',url=>'/admin/cities/edit/?cities[id]=2'),	 * 			3=>array(attr='is_hidden is_unread',type=>'element',title=>'Wood Street',url=>'/admin/cities/edit/?cities[id]=3'),	 * 		)),	 * 	)),	 * 	3=>array(type=>'folder_empty',title=>'Антарктида'),	 * )	 * атрибут type может принимать следующие строковые значения:	 * string "folder_empty","folter_closed","folder_opened","element","element_current"	 * а также может быть массивом из двух значений - первое определяет тип папки, второе - тип элемента	 * @param $models_grouppers_arr array	 * @return array	 */	function drawModelsElementsTree($models_grouppers_arr){		//_print_r('call drawModelsElementsTree() $models_grouppers_arr',$models_grouppers_arr);		$result=$this->drawModelsElementsTreeRec($models_grouppers_arr);		return $result;	}	/**	 * вспомогательный рекурсивный метод, вызывается в $this->drawModelsElementsTree()	 * состоит из четырех шагов: 	 * 	получение списка элементов, 	 * 	получение фильтра $filter и контейнера $container_id,	 * 	преобразование списка элементов,	 * 	рекурсия	 * @param $models_grouppers_arr array	 * @param $filter string - фрагмент sql-запроса фильтрующий элементы какой-то модели	 * @return array	 */	function drawModelsElementsTreeRec($models_grouppers_arr,$filter='1',$get=''){		// _print_r('---------drawModelsElementsTreeRec------------------------------------------------------------');		// _print_r('call drawModelsElementsTreeRec(), $models_grouppers_arr',$models_grouppers_arr);		//получаем список элементов		$elements=$this->drawModelsElementsTreeGetElements($models_grouppers_arr,$filter,$get);		// _print_r('$elements',$elements);		//получаем id контейнера который будет содержать дочерние элементы		//этот метод может изменить массив $models_grouppers_arr		list($models_grouppers_arr_reduced,$filter,$get,$container_id)=$this->drawModelsElementsTreeGetContainerId($models_grouppers_arr,$filter,$get);		// _print_r('===$models_grouppers_arr_reduced,$filter,$get',$models_grouppers_arr_reduced,$filter,$get);		//трансформируем полученные элементы		$result=$this->drawModelsElementsTreeTransform($models_grouppers_arr,$elements,$container_id,$get);		//_print_r('$result',$result);		if(!empty($container_id)){			//запускаем рекурсию, подключая новую порцию элементов в виде детей найденного контейнера			$elements=$this->drawModelsElementsTreeRec($models_grouppers_arr_reduced,$filter,$get);			if(IS_AJAX===true && !empty($elements)){				$result=$elements;			}else{				$result[$container_id]['children']=$elements;			}		}		return $result;	}	/**	 * возвращает список элементов	 * @param $models_grouppers_arr array	 * @param $filter string	 * @return array	 */	function drawModelsElementsTreeGetElements($models_grouppers_arr,$filter,$get){		// _print_r('call drawModelsElementsTreeGetElements(), $filter='.$filter.', $get='.$get);		reset($models_grouppers_arr);		//получаем группираторы текущей модели		$grouppers_arr=current($models_grouppers_arr);		//если их количество равно нулю, значит нужно вернуть список элементов согласно фильтру		if(count($grouppers_arr)==0){			$model_name=key($models_grouppers_arr);			$model_obj=gmo($model_name);			//переопределяяем фильтр, если осуществляется поиск по подстроке			//_print_r('$filter='.$filter);			if(p2v('tf')){				$filter=$model_obj->_getTypeFilter();				//_print_r('$filter='.$filter);			}			//получаем все элементы модели $model_name			//_print_r('$model_obj',$model_obj);			$filter=$this->drawModelsElementsTreeFilterFromGet($model_name,$get,$filter);			//_print_r('latest $filter='.$filter);			$mm=$model_obj->ga(array(				'fields'=>'*',//список полей которые нужно вытащить через запятую 'id,name,body'				'order_by'=>$model_obj->__admin__['ordering'],//строка типа или '-cdate' 'parent, +name' или '__random__' - случайный порядок				'filter'=>sprintf('%s and %s',$filter,$model_obj->_getFilterForModelTableQuery()),				// 'format'=>'id',//название поля (например 'id'), значение которого будет лежать в ключах результирующего массива				//'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)				'_obj'=>true,			));			$elements=$mm->_slice(0);			// _print_r('$modelmanager is ',$mm);		}else{			//получаем первый группиратор, его тип и значение			list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);			if(strtolower($groupper_class)=='datefield' || strtolower($groupper_class)=='datetimefield' || strtolower($groupper_class)=='timestampfield'){				$elements=$this->drawModelsElementsTreeGetElementsDateField($models_grouppers_arr,$filter);			}elseif(strtolower($groupper_class)=='intfield' || strtolower($groupper_class)=='charfield'){				$elements=$this->drawModelsElementsTreeGetElementsIntCharField($models_grouppers_arr,$filter);			}elseif(strtolower($groupper_class)=='treefield'){				$elements=$this->drawModelsElementsTreeGetElementsTreeField($models_grouppers_arr,$filter);			}elseif(strtolower($groupper_class)=='foreignkeyfield'){				$elements=$this->drawModelsElementsTreeGetElementsForeignKeyField($models_grouppers_arr,$filter);			}		}		return $elements;	}			function drawModelsElementsTreeFilterFromGet($current_model_name,$get,$filter='1'){		if(!empty($get)){			$get_filter='1';			foreach(explode('&',$get) as $item){				$item=trim($item);				if(!empty($item)){					list($key,$value)=explode('=',$item);					//$key сейчас это строка вида model_name[groupper]					$key=mb_substr($key,0,-1);					list($model_name,$groupper_name)=explode('[',$key);					if($model_name==$current_model_name){						$get_filter.=e5csql(' and `@`=?',$groupper_name,$value);					}				}			}		}		if(isset($get_filter) && $get_filter!='1'){			$filter=$get_filter;		}		return $filter;	}	/**	 * частный случай метода сбора списка элементов для поля типа DateField	 * @param $models_grouppers_arr array	 * @param $filter string	 * @return array	 */	function drawModelsElementsTreeGetElementsDateField($models_grouppers_arr,$filter){		//_print_r('call drawModelsElementsTreeGetElementsDateField() $filter=',$filter);		reset($models_grouppers_arr);		$model_name=key($models_grouppers_arr);		$model_obj=gmo($model_name);		//получаем группираторы текущей модели		$grouppers_arr=current($models_grouppers_arr);		list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);		//нужно определить что именно возвращать - года или месяца		$date_arr=explode('-',$groupper_value);		//_log('$date_arr,$filter',$date_arr,$filter);		if(mb_substr($date_arr[1],0,1)=='m'){			//возвращаем элементы			$elements=$model_obj->ga(array(				'fields'=>'*',//список полей которые нужно вытащить через запятую 'id,name,body'				'filter'=>sprintf('%s and %s',$filter,$this->_getFilterForModelTableQuery()),				'order_by'=>$model_obj->__admin__['ordering'],//строка типа или '-cdate' 'parent, +name' или '__random__' - случайный порядок				'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)			));		}elseif(mb_substr($date_arr[0],0,1)=='y'){			//возвращаем месяцы			$months=$model_obj->ga(array(				'filter'=>$filter,				'extra'=>array('select'=>'year('.$groupper_name.') as __y, month('.$groupper_name.') as __m','where'=>'1 group by __m'),//массив типа array('select'=>'id,body', 'where'=>'parent>?', 'params'=>$parent)				'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)			));//_print_r($years);			$elements=$months;		}else{			//возвращаем года			$years=$model_obj->ga(array(				'filter'=>$filter,				'extra'=>array('select'=>'year('.$groupper_name.') as __y','where'=>'1 group by __y'),//массив типа array('select'=>'id,body', 'where'=>'parent>?', 'params'=>$parent)				'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)			));//_print_r($years);			$elements=$years;		}		return $elements;	}	/**	 * частный случай алгоритма сбора списка элементов для полей типа IntField или CharField	 * @param $models_grouppers_arr array	 * @param $filter string	 * @return array	 */	function drawModelsElementsTreeGetElementsIntCharField($models_grouppers_arr,$filter){		//_print_r('call drawModelsElementsTreeGetElementsIntCharField(), $filter='.$filter);		reset($models_grouppers_arr);		$model_name=key($models_grouppers_arr);		$model_obj=gmo($model_name);		//получаем группираторы текущей модели		$grouppers_arr=current($models_grouppers_arr);		list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);		//_print_r('$groupper_name,$groupper_class,$groupper_value',$groupper_name,$groupper_class,$groupper_value);		if(mb_substr($groupper_value,0,3)=='___'){			$elements=$model_obj->ga(array(				'fields'=>'*',//список полей которые нужно вытащить через запятую 'id,name,body'				'filter'=>sprintf('%s and %s',$filter,$this->_getFilterForModelTableQuery()),				'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)			));		}else{			$elements=$model_obj->ga(array(				'fields'=>$groupper_name,//список полей которые нужно вытащить через запятую 'id,name,body'				'filter'=>$filter,				'extra'=>array('where'=>'1 group by '.$groupper_name),//массив типа array('select'=>'id,body', 'where'=>'parent>?', 'params'=>$parent)				'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)			));			if(is_array($model_obj->$groupper_name->choices)){				foreach($elements as $key=>$item){					$elements[$key][$groupper_name.'_txt']=$model_obj->$groupper_name->choices[$item[$groupper_name]];				}			}		}		return $elements;	}		function drawModelsElementsTreeGetElementsForeignKeyField($models_grouppers_arr,$filter){		// _print_r('call drawModelsElementsTreeGetElementsForeignKeyField(), $filter='.$filter);		reset($models_grouppers_arr);		$model_name=key($models_grouppers_arr);		$model_obj=gmo($model_name);		//получаем группираторы текущей модели		$grouppers_arr=current($models_grouppers_arr);		list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);		// _print_r('$groupper_name,$groupper_class,$groupper_value',$groupper_name,$groupper_class,$groupper_value);		$filter.=sprintf(' and %s=%d',$groupper_name, $groupper_value);		$elements=$model_obj->ga(array(			'fields'=>'*',//список полей которые нужно вытащить через запятую 'id,name,body'			'filter'=>sprintf('%s and %s',$filter,$model_obj->_getFilterForModelTableQuery()),			'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)		));		return $elements;	}		/**	 * частный случай алгоритма сбора списка элементов для поля типа TreeField	 * @param $models_grouppers_arr array	 * @param $filter string	 * @return array	 */	function drawModelsElementsTreeGetElementsTreeField($models_grouppers_arr,$filter){		reset($models_grouppers_arr);		$model_name=key($models_grouppers_arr);		$model_obj=gmo($model_name);		//получаем группираторы текущей модели		$grouppers_arr=current($models_grouppers_arr);		list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);		//_print_r('$groupper_name,$groupper_class,$groupper_value',$groupper_name,$groupper_class,$groupper_value);		// $groupper_value может иметь такое значение '0,1' и поэтому преобразуем строку к целому, отбрасывая запятую и все что после нее		$groupper_value=intval($groupper_value);		$elements=$model_obj->ga(array(			'fields'=>'*',//список полей которые нужно вытащить через запятую 'id,name,body'			'filter'=>e5csql('@ and @ and `@`=?',$filter,$model_obj->_getFilterForModelTableQuery(),$groupper_name,$groupper_value),//строка фильтра типа 'parent=32'			'order_by'=>$model_obj->__admin__['ordering'],//строка типа или '-cdate' 'parent, +name' или '__random__' - случайный порядок			//'format'=>'',//название поля (например 'id'), значение которого будет лежать в ключах результирующего массива			'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)		));		//если к текущей модели привязана другая модель по ForeignKey, то нужно получить 		//элементы привязанной модели		$models_grouppers_arr_reduced=$this->reduceModelsGrouppersArr($this->reduceModelsGrouppersArr($models_grouppers_arr));		if(count($models_grouppers_arr_reduced)>0){			$related_model_name=key($models_grouppers_arr_reduced);			if($related_model_name!=$model_name){				$related_model_obj=gmo($related_model_name);				$rel_grouppers_arr=current($models_grouppers_arr_reduced);				list($rel_groupper_name,$rel_groupper_class,$rel_groupper_value)=$this->getGroupperDetails($rel_grouppers_arr);				$related_elements=$related_model_obj->ga(array(				'fields'=>'*',//список полей которые нужно вытащить через запятую 'id,name,body'				'filter'=>e5csql('`@`=?',$rel_groupper_name,$groupper_value),//строка фильтра типа 'parent=32'				'order_by'=>$related_model_obj->__admin__['ordering'],//строка типа или '-cdate' 'parent, +name' или '__random__' - случайный порядок					'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)				));				//_print_r('$related_elements',$related_elements);				$elements=array(					$model_name=>$elements,					$related_model_name=>$related_elements,				);			}		}		return $elements;	}		/**	 * получение ID контейнера $container_id - элемента, который будет содержать детей	 * и фильтра $filter	 * в некоторых случаях метод может преобразовывать полученный массив группираторов	 * @param $models_grouppers_arr array	 * @param $filter string	 * @return array($models_grouppers_arr array, $filter string, $container_id int)	 */	function drawModelsElementsTreeGetContainerId($models_grouppers_arr,$filter,$get){		// _print_r('--call drawModelsElementsTreeGetContainerId(), $filter='.$filter.', $get='.$get);		$container_id=0;		reset($models_grouppers_arr);		$key=key($models_grouppers_arr);		$grouppers_arr=current($models_grouppers_arr);		// _print_r('--$grouppers_arr',$grouppers_arr);		list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);		// _print_r('$groupper_name,$groupper_class,$groupper_value',$groupper_name,$groupper_class,$groupper_value,'--------');		//чтобы сделать трансформацию необходимо добавить информацию о типе элемента		//возможные типы: folder_closed, folder_empty, folder_opened, element_current, element		if(count($grouppers_arr)==0 && count($models_grouppers_arr)>1){			//чтобы иметь возможность определить является ли текущий набор элементов конечным			//(и не только для этого) редуцируем полученый массив $models_grouppers_arr			$models_grouppers_arr_reduced=$this->reduceModelsGrouppersArr($models_grouppers_arr);			//_print_r('--$models_grouppers_arr_reduced',$models_grouppers_arr_reduced);			//чтобы определить container_id нам нужно спуститься по всем моделям из $models_grouppers_arr			//и найти ту, которая имеет группиратор ForeignKeyField, смотрящий на текущую модель $key			$model_name=key($models_grouppers_arr_reduced);			//_print_r('--$model_name='.$model_name);			//_print_r('$key,$models_grouppers_arr_reduced',$key,$models_grouppers_arr_reduced);			list($related_model_name,$groupper_name,$groupper_class,$groupper_value)=$this->drawModelsElementsTreeFindRelatedModel($key,$models_grouppers_arr_reduced);			//_print_r('--$related_model_name,$groupper_name,$groupper_class,$groupper_value',$related_model_name,$groupper_name,$groupper_class,$groupper_value);			if($groupper_value>0){				$container_id=$groupper_value;				//добавляем условие в фильтр				//но только в том случае, если $groupper_name присутствует среди полей $model_name				$model_obj=gmo($model_name);				if(is_subclass_of($model_obj->$groupper_name,'Field')){					$filter.=e5csql(' and `@`=?',$groupper_name,$container_id);					//_print_r('$get',$get);				}				$get.=$related_model_name.'['.$groupper_name.']='.urlencode($groupper_value).'&';			}			$models_grouppers_arr=$this->reduceModelsGrouppersArr($models_grouppers_arr);			if($groupper_value>0){				$grouppers_arr=$models_grouppers_arr[$related_model_name];				//_print_r('==============',$grouppers_arr,$models_grouppers_arr);				//в этом случае мы преобразуем массив $models_grouppers_arr -				//убираем из него группиратор ForeignKeyField - он уже выполнил свою функцию				$models_grouppers_arr[$related_model_name]=array_slice($grouppers_arr,1);				//_print_r($models_grouppers_arr,'++++++++++++++++++');			}		}elseif(strtolower($groupper_class)=='datefield' || strtolower($groupper_class)=='datetimefield' || strtolower($groupper_class)=='timestampfield'){			$date_arr=explode('-',$groupper_value);			if(mb_substr($date_arr[1],0,1)=='m'){			}elseif(mb_substr($date_arr[0],0,1)=='y'){				$container_id=$date_arr[1];				$filter.=e5csql(' and month(`@`)=?',$groupper_name,$date_arr[1]);				//$get.=$key.'['.$groupper_name.']='.urlencode($groupper_value).'&';				$date_arr[1]='m'.$date_arr[1];				$models_grouppers_arr_reduced=$this->reduceModelsGrouppersArr($models_grouppers_arr);				$models_grouppers_arr=$models_grouppers_arr_reduced;			}elseif(!empty($groupper_value)){				$container_id=$date_arr[0];				$filter.=e5csql(' and year(`@`)=?',$groupper_name,$date_arr[0]);				//$get.=$key.'['.$groupper_name.']='.urlencode($groupper_value).'&';				$date_arr[0]='y'.$date_arr[0];				$grouppers_arr[$groupper_name]=$groupper_class.','.implode('-',$date_arr);				$models_grouppers_arr[$key]=$grouppers_arr;			}		}elseif(strtolower($groupper_class)=='intfield' || strtolower($groupper_class)=='charfield'){			$models_grouppers_arr_reduced=$this->reduceModelsGrouppersArr($models_grouppers_arr);			//проверяем, имеются ли у текущей модели еще группираторы после редуцирования			if(is_array($models_grouppers_arr_reduced[$key]) && count($models_grouppers_arr_reduced[$key])>0){				//да, имеются				$container_id=urlencode($groupper_value);				$filter.=e5csql(' and `@`=?',$groupper_name,$groupper_value);				$get.=$key.'['.$groupper_name.']='.urlencode($groupper_value).'&';				//_log('$get2='.$get);				$models_grouppers_arr=$models_grouppers_arr_reduced;				//$grouppers_arr=current($models_grouppers_arr_reduced);				//list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);			}else{				//отсутствуют, возвращаем id контейнера или 0				if(mb_substr($groupper_value,0,3)!='___'){					$container_id=urlencode($groupper_value);					$filter.=e5csql(' and `@`=?',$groupper_name,$groupper_value);					//$get.=$key.'['.$groupper_name.']='.urlencode($groupper_value).'&';					//_log('$get3='.$get);					$grouppers_arr[$groupper_name]=$groupper_class.',___'.$groupper_value;					$models_grouppers_arr[$key]=$grouppers_arr;				}			}		}elseif(strtolower($groupper_class)=='treefield'){			$ids=explode(',',$groupper_value);			$id_bak=array_shift($ids);			if(count($ids)>0){				$container_id=$ids[0];				$filter=explode(' and ',$filter);				array_pop($filter);				$filter[]=e5csql('`@`=?',$groupper_name,$ids[0]);				$filter=implode(' and ',$filter);				//TODO здесь непонятно как будет...				//$get.=$key.'['.$groupper_name.']='.urlencode($groupper_value).'&';				$grouppers_arr[$groupper_name]=$groupper_class.','.implode(',',$ids);				$models_grouppers_arr[$key]=$grouppers_arr;			}else{				$grouppers_arr[$groupper_name]=$groupper_class;				$models_grouppers_arr[$key]=$grouppers_arr;				//_print_r('$models_grouppers_arr',$models_grouppers_arr);				$models_grouppers_arr_reduced=$this->reduceModelsGrouppersArr($models_grouppers_arr);				// _print_r('count($models_grouppers_arr_reduced)',count($models_grouppers_arr_reduced));				if(count($models_grouppers_arr_reduced)>2){					unset($models_grouppers_arr_reduced[$key]);					$next_key=key($models_grouppers_arr_reduced);					// _print_r('$next_key$next_key='.$next_key);					unset($models_grouppers_arr_reduced[$next_key]);					// _print_r('$models_grouppers_arr_reduced',$models_grouppers_arr_reduced);					// _print_r('$models_grouppers_arr_reduced===',$models_grouppers_arr_reduced);					$grouppers_arr=current($models_grouppers_arr_reduced);					if(!empty($grouppers_arr)){						list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);						if($groupper_class=='ForeignKeyField'){							$filter='1';							$get='';							$container_id='_'.$groupper_value;							return array($models_grouppers_arr_reduced,$filter,$get,$container_id);						}					}				}				//проверяем, имеются ли у текущей модели еще группираторы после редуцирования				//_print_r('$models_grouppers_arr_reduced',$models_grouppers_arr_reduced);			}		}		return array($models_grouppers_arr,$filter,$get,$container_id);	}		function drawModelsElementsTreeFindRelatedModel($key,$models_grouppers_arr_reduced){		$loop=0;		while(!empty($models_grouppers_arr_reduced) && $loop++<9){			$grouppers_arr=current($models_grouppers_arr_reduced);			if(!empty($grouppers_arr)){				list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);				if(strtolower($groupper_class)=='foreignkeyfield'){					$model_name=key($models_grouppers_arr_reduced);					$model_obj=gmo($model_name);					$field_obj=$model_obj->$groupper_name;					if($field_obj->modelrel==$key){						return array($model_name,$groupper_name,$groupper_class,$groupper_value);						break;					}				}			}			$models_grouppers_arr_reduced=$this->reduceModelsGrouppersArr($models_grouppers_arr_reduced);		}	}		/**	 * преобразование списка элементов - каждый элемент содержит все поля своей модели	 * данный метод отбрасывает все поля и создает только три поля: type, title и url	 * @param $models_grouppers_arr array	 * @param $elements array	 * @param $container_id int	 * @return array	 */	function drawModelsElementsTreeTransform($models_grouppers_arr,$elements,$container_id,$get){		// _print_r('call drawModelsElementsTreeTransform(), $container_id='.$container_id.', $get='.$get);		//_print_r('$elements',$elements);		$result=array();		$grouppers_arr=current($models_grouppers_arr);		list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);		//чтобы сделать трансформацию необходимо добавить информацию о типе элемента		//возможные типы: folder_closed, folder_empty, folder_opened, element_current, element		if(count($grouppers_arr)==0 && count($models_grouppers_arr)>1){			//элементы являются папками (folder_closed, folder_empty, folder_opened)			//поскольку к ним привязана следующая модель через ключ ForeignKeyField			$result=$this->drawModelsElementsTreeTransformForeignKeyField($models_grouppers_arr,$elements,$container_id,$get);		}elseif(strtolower($groupper_class)=='datefield' || strtolower($groupper_class)=='datetimefield' || strtolower($groupper_class)=='timestampfield'){			$result=$this->drawModelsElementsTreeTransformDateField($models_grouppers_arr,$elements,$container_id,$get);		}elseif(strtolower($groupper_class)=='intfield' || strtolower($groupper_class)=='charfield'){			$result=$this->drawModelsElementsTreeTransformIntCharField($models_grouppers_arr,$elements,$container_id,$get);		}elseif(strtolower($groupper_class)=='treefield'){			$result=$this->drawModelsElementsTreeTransformTreeField($models_grouppers_arr,$elements,$container_id);		}else{			$model_name=key($models_grouppers_arr);			$model_obj=gmo($model_name);			//элементы являются конечными (element_current, element)			$current_id=$this->getModelItemIdFromGetQuery();			if(count($elements)>0){				foreach($elements as $item){					if($item['id']==$current_id){						$type='element_current';					}else{						$type='element';					}					$result[$item['id']]=array(						'type'=>$type,						'title'=>$model_obj->__str__($item),						'url'=>'/admin/'.$GLOBALS['path'][2].'/edit/?'.$model_name.'[id]='.$item['id'],						'attr'=>$this->drawModelsElementsTreeTransformGetAttr($item),					);				}			}		}		return $result;	}	/**	 * просто собираем атрибуты hidden active и пр. на основе полей is_hidden, is_active и пр.	 */	function drawModelsElementsTreeTransformGetAttr($item){		$attr=array();		foreach(array_keys($item) as $property){			if(mb_substr($property,0,3)=='is_' && $item[$property]=='yes'){				$attr[]=mb_substr($property,3);			}		}		if(count($attr)>0){			return implode(' ',$attr);		}	}	/**	 * частный случай метода трансформации списка элементов для группиратора типа ForeignKeyField	 * @param $models_grouppers_arr array	 * @param $elements array	 * @param $container_id int	 * @return array	 */	function drawModelsElementsTreeTransformForeignKeyField($models_grouppers_arr,$elements,$container_id,$get){		//_print_r('call drawModelsElementsTreeTransformForeignKeyField()');		//_print_r('$models_grouppers_arr,$elements,$container_id',$models_grouppers_arr,$elements,$container_id);		$result=array();		$key=key($models_grouppers_arr);		$models_grouppers_arr_reduced=$this->reduceModelsGrouppersArr($models_grouppers_arr);		//_print_r('$key,$models_grouppers_arr_reduced',$key,$models_grouppers_arr_reduced);		list($related_model_name,$groupper_name,$groupper_class,$groupper_value)=$this->drawModelsElementsTreeFindRelatedModel($key,$models_grouppers_arr_reduced);		//_print_r('----$key,$models_grouppers_arr_reduced',$key,$models_grouppers_arr_reduced);		//_print_r('----$related_model_name,$groupper_name,$groupper_class,$groupper_value',$related_model_name,$groupper_name,$groupper_class,$groupper_value);		//пробегаем по элементам и для каждого определяем кол-во привязанных элементов привяз. модели		$model_obj=gmo($key);		foreach($elements as $item) {			$filter=e5csql('`@`=?',$groupper_name,$item['id']);			//_print_r('$filter',$filter);			$filter=$this->drawModelsElementsTreeFilterFromGet($model_name,$get,$filter);			//_print_r('$filter',$filter);			$mm=ga(array(				'classname'=>$related_model_name,				'fields'=>'*',//список полей которые нужно вытащить через запятую 'id,name,body'				'filter'=>$filter,//строка фильтра типа 'parent=32'				'_obj'=>true,				//'_count'=>true,//возвратит кол-во элементов в выборке			));			$count=$mm->_count();			//_print_r($mm);			if($count==0){				$type='folder_empty';			}elseif ($item['id']==$container_id) {				$type='folder_opened';			}else {				$type='folder_closed';			}			$result[$item['id']]=array(				'type'=>$type,				'title'=>$model_obj->__str__($item),				'url'=>'/admin/'.$GLOBALS['path'][2].'/?'.$get.$related_model_name.'['.$groupper_name.']='.$item['id'],				'attr'=>$this->drawModelsElementsTreeTransformGetAttr($item),			);		}		return $result;	}	/**	 * частный случай метода трансформации списка элементов для группиратора типа DateField	 * @param $models_grouppers_arr array	 * @param $elements array	 * @param $container_id int	 * @return array	 */	function drawModelsElementsTreeTransformDateField($models_grouppers_arr,$elements,$container_id,$get){		//_print_r('$models_grouppers_arr',$models_grouppers_arr);		//_print_r('call drawModelsElementsTreeTransformDateField()',$elements);		$result=array();		reset($models_grouppers_arr);		$model_name=key($models_grouppers_arr);		$grouppers_arr=current($models_grouppers_arr);		list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);		$date_arr=explode('-',$groupper_value);		//mb_strpos($groupper_value,'y')>0		if(mb_substr($date_arr[1],0,1)=='m'){			$model_obj=gmo($model_name);			foreach($elements as $item){				$type=($item['id']==$_GET[$model_name]['id'])?'element_current':'element';				$result[$item['id']]=array(					'type'=>$type,					'title'=>$model_obj->__str__($item),					'url'=>'/admin/'.$GLOBALS['path'][2].'/edit/?'.$model_name.'[id]='.$item['id'],					'attr'=>$this->drawModelsElementsTreeTransformGetAttr($item),				);			}		}elseif(mb_substr($date_arr[0],0,1)=='y'){			foreach($elements as $item){				$type=($item['__m']==$container_id)?'folder_opened':'folder_closed';				$item['__m']=sprintf('%02d',$item['__m']);				$result[$item['__m']]=array(					'type'=>$type,					'title'=>month($item['__m']),					'url'=>'/admin/'.$GLOBALS['path'][2].'/?'.$get.$model_name.'['.$groupper_name.']='.$item['__y'].'-'.$item['__m'],				);			}		}else{			foreach ($elements as $item){				$type=($item['__y']==$container_id)?'folder_opened':'folder_closed';				$result[$item['__y']]=array(					'type'=>$type,					'title'=>$item['__y'],					'url'=>'/admin/'.$GLOBALS['path'][2].'/?'.$get.$model_name.'['.$groupper_name.']='.$item['__y'],				);			}		}		return $result;	}	/**	 * частный случай метода трансформации списка элементов для группираторов типа IntField и CharField	 * @param $models_grouppers_arr array	 * @param $elements array	 * @param $container_id int	 * @return array	 */	function drawModelsElementsTreeTransformIntCharField($models_grouppers_arr,$elements,$container_id,$get){		//_print_r('here drawModelsElementsTreeTransformIntCharField(), $container_id='.urldecode($container_id));		$model_name=key($models_grouppers_arr);		$model_obj=gmo($model_name);		$grouppers_arr=current($models_grouppers_arr);		list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);		if(mb_substr($groupper_value,0,3)=='___'){			foreach($elements as $item){				$type=($item['id']==$model_obj->getModelItemIdFromGetQuery())?'element_current':'element';				$result[$item['id']]=array(					'type'=>$type,					'title'=>$model_obj->__str__($item),					'url'=>'/admin/'.$GLOBALS['path'][2].'/edit/?'.$model_name.'[id]='.$item['id'],					'attr'=>$this->drawModelsElementsTreeTransformGetAttr($item),				);			}		}else{			foreach($elements as $item){				$encoded=urlencode($item[$groupper_name]);				$type=($encoded==$container_id)?'folder_opened':'folder_closed';				$result[$encoded]=array(					'type'=>$type,					'title'=>defvar($item[$groupper_name],$item[$groupper_name.'_txt']),					'url'=>'/admin/'.$GLOBALS['path'][2].'/?'.$get.$model_name.'['.$groupper_name.']='.$encoded,				);			}		}		return $result;	}		/**	 * частный случай метода трансформации списка элементов для группиратора типа TreeField	 * @param $models_grouppers_arr array	 * @param $elements array	 * @param $container_id int	 * @return array	 */	function drawModelsElementsTreeTransformTreeField($models_grouppers_arr,$elements,$container_id){		//_print_r('call drawModelsElementsTreeTransformTreeField() $models_grouppers_arr',$models_grouppers_arr,'$elements',$elements);		$model_name=key($models_grouppers_arr);		$model_obj=gmo($model_name);		$grouppers_arr=current($models_grouppers_arr);		list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);		$models_grouppers_arr_reduced=$this->reduceModelsGrouppersArr($this->reduceModelsGrouppersArr($models_grouppers_arr));		if(count($models_grouppers_arr_reduced)>0){			$related_model_name=key($models_grouppers_arr_reduced);			if($related_model_name!=$model_name){				list($rel_groupper_name,$null,$null)=$this->getGroupperDetails(current($models_grouppers_arr_reduced));				$related_model_obj=gmo($related_model_name);				$related_elements=$elements[$related_model_name];				$elements=$elements[$model_name];			}		}		foreach($elements as $item){			//количество детей той же модели			$children_count=$model_obj->ga(array(				'filter'=>e5csql('`@`=?',$groupper_name,$item['id']),//строка фильтра типа 'parent=32'				'_count'=>true,//возвратит кол-во элементов в выборке			));			//в древовидных списках есть ссылка с папки плюс/минус и ссылка с элемента, они не одинаковы			$type=array();			$url=array();			//определяем ссылку с элемента (позже может быть переопределена)			$element_type=($item['id']==$this->getModelItemIdFromGetQuery())?'element_current':'element';			$element_url='/admin/'.$GLOBALS['path'][2].'/edit/?'.$model_name.'[id]='.$item['id'];			if(isset($related_model_obj)){				//если к древовидной модели привязана другая модель				//определяем кол-во привязанных элементов				$related_count=$related_model_obj->ga(array(					'filter'=>e5csql('`@`=?',$rel_groupper_name,$item['id']),//строка фильтра типа 'parent=32'					'_count'=>true,//возвратит кол-во элементов в выборке				));				//_print_r('$item[id]='.$item['id'].', $children_count='.$children_count,' $related_count='.$related_count);				if($children_count>0 || $related_count>0){					$type=($container_id==$item['id'])?'folder_opened':'folder_closed';					$url='/admin/'.$GLOBALS['path'][2].'/?'.$model_name.'['.$groupper_name.']='.$item['id'];				}else{					$type='folder_empty';					$url='';				}			}elseif($children_count>0){				//в данном случае (например, модель Структура) для дерева необходимо передавать ДВА типа и ДВЕ ссылки - на иконку папки и на сам элемент				$type['folder']=($container_id==$item['id'])?'folder_opened':'folder_closed';				$type['element']=$element_type;				$url['folder']='/admin/'.$GLOBALS['path'][2].'/?'.$model_name.'['.$groupper_name.']='.$item['id'];				$url['element']=$element_url;			}else{				$type=$element_type;				$url=$element_url;			}			$result[$item['id']]=array(				'type'=>$type,				'title'=>$model_obj->__str__($item),				'url'=>$url,				'attr'=>$this->drawModelsElementsTreeTransformGetAttr($item),			);		}		// _print_r('$related_elements are ',$related_elements);		if(!empty($related_elements)){			// тут возможны два варианта: элементы являются конечными (это простой случай)			// и элементы являются не конечными, то есть могут иметь детей			if(count($models_grouppers_arr_reduced)>1){				// сложный случай				$grouppers_arr=next($models_grouppers_arr_reduced);				list($groupper_name,$groupper_class,$groupper_value)=$this->getGroupperDetails($grouppers_arr);				$children_model_name=key($models_grouppers_arr_reduced);				$children_model_obj=gmo($children_model_name);			}			foreach ($related_elements as $item){				$data=array(					'title'=>$related_model_obj->__str__($item),					'attr'=>$this->drawModelsElementsTreeTransformGetAttr($item),				);				if(count($models_grouppers_arr_reduced)>1){					// сложный случай					$children_count=$children_model_obj->ga(array(						'filter'=>e5csql('`@`=?',$groupper_name,$item['id']),//строка фильтра типа 'parent=32'						'_count'=>true,//возвратит кол-во элементов в выборке					));					if($children_count>0){						if( '_'.$item['id'] == $container_id ){							$data['type']='folder_opened';						}else{							$data['type']='folder_closed';							$data['url']=sprintf('/admin/%s/?%s[%s]=%d',$GLOBALS['path'][2],$children_model_name,$groupper_name,$item['id']);							// .$related_model_name.'[id]='.$item['id']						}					}else{						$data['type']='folder_empty';					}				}else{					// простой случай					$data['type']=($item['id']==$this->getModelItemIdFromGetQuery())?'element_current':'element';					$data['url']='/admin/'.$GLOBALS['path'][2].'/edit/?'.$related_model_name.'[id]='.$item['id'];				}				$result['_'.$item['id']]=$data;			}		}		return $result;	}	/**	 * уменьшаем либо кол-во группираторов, либо кол-во моделей, если нет группираторов	 * @param $models_grouppers_arr	 * @return unknown_type	 */	function reduceModelsGrouppersArr($models_grouppers_arr){		//_print_r('call reduceModelsGrouppersArr(), $models_grouppers_arr',$models_grouppers_arr);		reset($models_grouppers_arr);		$model_name=key($models_grouppers_arr);		$grouppers_arr=current($models_grouppers_arr);		if(is_array($grouppers_arr) && count($grouppers_arr)>0){			//_print_r('a');			$grouppers_arr=array_slice($grouppers_arr,1);			$models_grouppers_arr[$model_name]=$grouppers_arr;			//_log('2 $models_grouppers_arr=',$models_grouppers_arr);		}else{			//_print_r('b');			$models_grouppers_arr=array_slice($models_grouppers_arr,1);			//_print_r('3 $models_grouppers_arr',$models_grouppers_arr);		}		return $models_grouppers_arr;	}	/**	 * возвращает информацию о текущем группираторе (класс, название, значение) 	 * на основе данных из массива $grouppers_arr	 * @param $grouppers_arr array	 * @return array	 */	function getGroupperDetails($grouppers_arr){		reset($grouppers_arr);		$groupper_name=key($grouppers_arr);		$groupper_class_value=current($grouppers_arr);//_log('$groupper_class_value='.$groupper_class_value);		if(!empty($groupper_class_value)){			//_die('$groupper_class_value is empty');			$groupper_class_value=explode(',',$groupper_class_value,2);			$groupper_class=$groupper_class_value[0];			$groupper_value=$groupper_class_value[1];			//if(empty($groupper_value)){return;/*_die('$groupper_value is empty');*/}		}		return array($groupper_name,$groupper_class,$groupper_value);	}	//=======================	function getModelItemEditZone(){//возвращает HTML-код фрагмента страницы, где производится редактирование элемента модели		//проверяем должен ли этот модуль показываться в админке		if($this->userCanSeeModelInAdmin() || $_SESSION['admin_user']['su']){			if(EDIT_MODE===true){				if(p2v('send')=='yes'){					$result=$this->parsePostedData();				}else{					if($this->getModelItemIdFromGetQuery()>0){						if($this->userCanEditModelItems() || $_SESSION['admin_user']['su']){							$result=$this->getModelItemEditFormHTML();						}					}else{						if($this->userCanAddModelItems()){							$result=$this->getModelItemAddFormHTML();						}					}				}			}else{				$result=$this->getModelNameHTML();			}		}		return $result;	}	// HTML-код с русским названием модели	function getModelNameHTML(){		//подключаем отображение		include(FW_DIR.'/classes/templates/model/model_name.php');		//возваращаем		return $result;	}	// HTML-код формы редактирования элемента	function getModelItemEditFormHTML($model_item='',$errors_arr=''){		//получаем данные элемента модели		$mmanager=$this->objects();		$mmanager=$mmanager->filter($this->_getFilterForModelTableQuery());		$model_item_data=$mmanager->_get($this->getModelItemIdFromGetQuery());		// _print_r($model_item_data);		// возможно в массиве ничего нет кроме пустого $errors_arr['__rel_errors_arr__']		if( is_array($errors_arr) ){			if( array_key_exists('__rel_errors_arr__',$errors_arr) && empty($errors_arr['__rel_errors_arr__']) ){				unset($errors_arr['__rel_errors_arr__']);			}			if( !empty($errors_arr) ){				// _print_r('$errors_arr',$errors_arr);				// _log('$errors_arr',$errors_arr);				// возможно есть отчеты об ошибках в привязанных моделях				if( isset($errors_arr['__rel_errors_arr__']) ){					$errors_report='';					foreach($errors_arr['__rel_errors_arr__'] as $rel_model_name=>$rel_report){						$errors_report.=sprintf('<p class="alert"><b>Не были сохранены данные в привязанной модели «%s»:<br></b>%s</p>',$GLOBALS['INSTALLED_APPS'][$rel_model_name],$rel_report);					}				}else{					$errors_report=sprintf('<p class="alert"><b>Данные не были сохранены:<br></b>%s</p>', $model_item->errReport($errors_arr));				}				if(!empty($model_item_data)){					// если форма показывается повторно из-за возникших ошибок,					// то нужно показать отправленные в POST-е данные,					// то есть переопределить некоторые поля в полученном из БД массиве $model_item_data					$model_item_data=$model_item->_getPostedModelItemDataArr($model_item_data);				}else{					$model_item_data=$_POST[$this->__name__];				}			}		}		//генерим поля формы редактирования привязанных моделей у которых core=true		$this->__core__=$this->getCoreFields();//_echo(e5c($this->__core__));		//подключаем отображение		include(FW_DIR.'/classes/templates/model/model_item_form.php');		//возваращаем		return $result;	}	function getModelItemAddFormHTML(){//возвращает HTML-код формы добавления элемента		//получаем данные элемента модели по умолчанию		foreach(get_object_vars($this) as $field_name=>$obj_field){			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				$model_item_data[$field_name]=$obj_field->default;			}		}		//подключаем отображение		//_print_r($this);_die('stop');		include(FW_DIR.'/classes/templates/model/model_item_form.php');		//возваращаем		return $result;	}	function getCoreFieldsHTML($db_column,$rel_item_id,$num_in_admin){		//перебираем поля модели в поисках core=true		foreach(get_object_vars($this) as $field_name=>$obj_field){			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				if($obj_field->core){					$core_fields_arr[]=$field_name;				}			}		}//_print_r($core_fields_arr);		$result='';		if(is_array($core_fields_arr) && count($core_fields_arr)>0){			//итак, теперь известно что у модели $this имеются поля core=true			//следовательно нужно вытащить из базы строки, соответствующие нужному $rel_item_id			$rel_items=$this->objects();			$rel_items=$rel_items->filter($db_column.'='.$rel_item_id);			if($this->__name__=='_modelsfields'){				$rel_items=$rel_items->filter('db_column!="id" && db_column!="ip" && db_column!="mdate"');			}			$rel_items=$rel_items->_slice(0);//_print_r($rel_items);			$num=0;			if(is_array($rel_items)){				foreach($rel_items as $item){					$num++;					$result.=$this->getModelItemCoreFieldHTML($item,$core_fields_arr,$num);				}			}//_echo(e5c($result));			//добавляем несколько пустых строк			if($num_in_admin>0){				for($i=1;$i<=$num_in_admin;$i++){					$num++;					$result.=$this->getModelItemCoreFieldHTML($i,$core_fields_arr,$num);				}			}			if(!empty($result)){				//заворачиваем полученный код в еще один шаблон				include(FW_DIR.'/classes/templates/model/model_core_wrap.php');			}		}		return $result;	}	function getModelItemCoreFieldHTML($item_data_arr_or_int,$core_fields_arr,$num){		//подключаем отображение		include(FW_DIR.'/classes/templates/model/model_item_core_form.php');		return $result;	}	function getModelItemClientAddFormHTML($acc_fields='',$native_data='',$errors_arr=array()){//возвращает HTML-код формы добавления элемента для клиентской части		if(isset($_REQUEST[$this->__name__])){			$model_item_data=$_REQUEST[$this->__name__];		}elseif(!empty($native_data)){			$model_item_data=$native_data;		}else{			$model_item_data=array();		}		//подключаем отображение		include(FW_DIR.'/classes/templates/model/model_item_form_client.php');		//возваращаем		return $result;	}	function getModelItemFieldsPairsHTML($fields_list_str=''){//возвращает HTML-код пар поля и значения для отправки на мыло		if($fields_list_str!=''){			$fields_list=explode(',',$fields_list_str);		}		foreach(get_object_vars($this) as $field_name=>$obj_field){			if(is_array($fields_list) && in_array($field_name, $fields_list)===false){continue;}			if(is_object($obj_field) && is_subclass_of($obj_field,'Field') && $obj_field->editable && $field_name!='id'){				if( IS_AJAX!==true ){					$value=e5c($_POST[$this->__name__][$field_name]);				}else{					$value=e5c($_REQUEST[$this->__name__][$field_name]);				}				if(is_array($obj_field->choices)){					$value=$obj_field->choices[$value];				}				$model_item_data[]=array(					'txt_name'=>$obj_field->txt_name,					'value'=>$value,				);			}		}//_print_r($model_item_data);		//подключаем отображение		include(FW_DIR.'/classes/templates/model/model_item_fields_pairs.php');		//возваращаем		return $result;	}	//ACCESS	function userCanSeeModelInAdmin(){//возвращает true если юзер имеет право на совершение какого-либо действия с моделью		return ($this->userCanAddModelItems() || $this->userCanEditModelItems() || $this->userCanDeleteModelItems() || $_SESSION['admin_user']['su']);	}	function userCanAddModelItems(){//возвращает true если юзер имеет право на добавление новых элементов в текущей модели		if(isset($this->__admin__['deny']) && mb_strpos($this->__admin__['deny'],'add')!==false){			return false;		}else{			return ($_SESSION['admin_user']['su'] || $_SESSION['admin_user']['access'][$this->__name__]['add']);		}	}	function userCanEditModelItems(){//возвращает true если юзер имеет право на редактирование элементов в текущей модели		if(isset($this->__admin__['deny']) && mb_strpos($this->__admin__['deny'],'edit')!==false){			return false;		}else{			return ($_SESSION['admin_user']['su'] || $_SESSION['admin_user']['access'][$this->__name__]['edit']);		}	}	function userCanDeleteModelItems(){//возвращает true если юзер имеет право на удаление элементов в текущей модели		if(isset($this->__admin__['deny']) && mb_strpos($this->__admin__['deny'],'delete')!==false){			return false;		}else{			return ($_SESSION['admin_user']['su'] || $_SESSION['admin_user']['access'][$this->__name__]['delete']);		}	}	//MODEL ITEM CHANGE	/**	 * метод преобразовывает $_POST и $_FILES	 * это бывает нужно для корректного сохранения данных из формы	 * если названия полей формы не содержат названия модели (т.е. email вместо users[email])	 * чтобы устранить данный недостаток, достаточно вызывать метод перед использованием gmi	 * $this->transformPOST()	 * $user=gmi($_POST['users']);	 * $err=$user->save();	 */	function transformPOST(){		$_POST[$this->__name__]=array();		foreach(get_object_vars($this) as $field_name=>$obj_field){			if( is_object($obj_field) && is_subclass_of($obj_field,'Field') ){				if( isset($_POST[$field_name]) ){					$_POST[$this->__name__][$field_name]=$_POST[$field_name];					unset($_POST[$field_name]);				}elseif( isset($_FILES[$field_name]) ){					$_FILES[$this->__name__]=array();					foreach(array('name','type','tmp_name','error','size') as $file_property){						$_FILES[$this->__name__][$file_property]=array($field_name=>$_FILES[$field_name][$file_property]);					}					unset($_FILES[$field_name]);					if( isset($_POST[$field_name.'_bak']) ){						$_POST[$this->__name__][$field_name.'_bak']=$_POST[$field_name.'_bak'];						unset($_POST[$field_name.'_bak']);					}				}			}		}	}	function parsePostedData(){//выполняет обработку пришедшего POST-запроса (сохраняет, изменяет или удаляет элемент модели)		//создаем новый элемент модели		$model_name=$this->__name__;		if(p2v('up')!='' || p2v('down')!='' || p2v('delete')!=''){			$model_item=gmi($model_name,$_POST[$model_name]['id']);		}else{			$model_item=gmi($model_name,$_POST[$model_name]);		}		if(p2v('delete')!=''){			if($this->userCanDeleteModelItems()){				//удаляем элемент				$linked_model_items_arr=$model_item->delete();				if(!empty($linked_model_items_arr)){					//подгружаем шаблон для отображения неудавшегося удаления					include(FW_DIR.'/classes/templates/model/cant_delete.php');				}			}		}elseif(p2v('up')!=''){//если сортировка меняется без ajax			if($this->userCanEditModelItems()){				//пытаемся переместить вверх				$model_item->moveUp();			}		}elseif(p2v('down')!=''){//если сортировка меняется без ajax			if($this->userCanEditModelItems()){				//пытаемся переместить вниз				$model_item->moveDown();			}		}elseif($model_item->id>0){			if($this->userCanEditModelItems()){				//сохраняем элемент				$errors_arr=$model_item->save();				//метод save() может нам вернуть массив ошибок с полями, которые не были заполнены, или были заполнены с ошибками				if(!empty($errors_arr)){					//снва показываем форму для редактирования					$result=$this->getModelItemEditFormHTML($model_item,$errors_arr);				}			}		}elseif($model_item->id==0){			if($this->userCanAddModelItems()){				//сохраняем элемент				$errors_arr=$model_item->save();				//метод save() может нам вернуть массив ошибок с полями, которые не были заполнены, или были заполнены с ошибками				if(!empty($errors_arr)){					//снва показываем форму для редактирования					$result=$this->getModelItemEditFormHTML($model_item,$errors_arr);				}			}		}		if(empty($result)){			//переходим на новую страницу			$this->_reloadAfterParseringPostedData($model_item->id);		}else{			return $result;		}	}	function getModelItemIdFromGetQuery(){//возвращает id элемента модели, определяемый из $_REQUEST		$request_arr=p2v($this->__name__);		$id=0;		if(isset($request_arr['id'])){			$id=(int)$request_arr['id'];		}		return $id;	}	function set($field,$value){//устанавливает новое значение элемента модели		if(!$this->__item__){_die('метод set() может быть вызван только элементом модели');}		$obj_model=gmo($this->__name__);		foreach(get_object_vars($obj_model) as $field_name=>$obj_field){			if($field_name==$field && is_object($obj_field) && is_subclass_of($obj_field,'Field')){				$this->$field=$value;				$this->_input[$field]=$value;			}		}	}	/**	 * сохраняет текущий элемент модели в БД, после сохранения у элемента модели появляются новые свойства (id и пр)	 *	 * @return array	 */	function save(){		//_print_r($_POST); _die('end');		if(!$this->__item__){_die('метод save() может быть вызван только элементом модели');}		//осуществляем валидацию: проверяем переданы ли обяз. поля,		//соответствуют ли значения типам		//а также проверяем нет ли лишних полей		$errors_arr=$this->_validateModelItemFieldsData();//echo('[');_print_r($errors_arr);echo(']');		if(empty($errors_arr)){			//сохраняем элемент в БД			$rel_errors_arr=$this->_performModelItemSave();			if( !empty($rel_errors_arr) ){				$errors_arr['__rel_errors_arr__']=$rel_errors_arr;			}			//для не специальных моделей после сохранения элемента в БД удаляем из кэша все страницы, привязанные к обновляемой модели			$obj_cache=gmo('_cache');			$obj_cache->clearModelCachedPages($this->__name__);		}		return $errors_arr;	}		/**	 * функция очищает данные, пришедшие из формы, затем вызывает стандартный ->save()	 *	 * @return array	 */	function ssave(){		if(!$this->__item__){_die('метод save() может быть вызван только элементом модели');}		//получаем объект модели		$obj_model=gmo($this->__name__);		foreach(get_object_vars($obj_model) as $field_name=>$obj_field){			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				if( is_a($obj_field,'PrimaryKeyField') || is_a($obj_field,'ManyToManyField') ){					continue;				}else{					if(is_subclass_of($obj_field,'SubfieldsInterface')){						foreach(array_keys($obj_field->subfields) as $key){							if(isset($_POST[$this->__name__])){								$subkey=$field_name.'_'.$key;								$_POST[$this->__name__][$subkey]=strip_tags($_POST[$this->__name__][$subkey]);							}else{								$this->_input['_relkey'][$this->__name__][$subkey]=strip_tags($this->_input['_relkey'][$this->__name__][$subkey]);							}						}					}else{						$this->$field_name=strip_tags(trim($this->$field_name));					}				}			}		}		$this->save();	}	/**	 * удаляет (точнее, пытается удалить) текущий элемент модели	 *	 * 1. сперва для элемента модели вызывается его метод checkModelItemRelations()	 *	 который возвращает $linked_model_items_arr или удаляет привязанные модели	 *	 перед удалением чистится кеш	 * 2. затем для модели вызываются beforeChange() и beforeDelete()	 * 3. затем для каждого поля вызывается его метод beforeDelete(),	 * 	 который должен выполнить действия, предшествующие удалению,	 * 	 например удалить файл(ы) с сервера	 * 4. наконец, исполняется sql-запрос, удаляющий элемент модели из БД	 * 5. еще после для модели вызываются afterDelete() и afterChange()	 * 6. и в самом конце убивается ссылка на элемент модели	 *	 * @return array		*/	function delete(){		if(!$this->__item__){_die('метод del() может быть вызван только элементом модели');}		$err_relations=$this->checkModelItemRelations();		if(empty($err_relations)){			//для не специальных моделей после сохранения элемента в БД удаляем из кэша все страницы, привязанные к обновляемой модели			$obj_cache=gmo('_cache');			$obj_cache->clearModelCachedPages($this->__name__);							//запускаем beforeChange()			$this->beforeChange();			//запускаем beforeDelete()			$this->beforeDelete();			//после всех before проходимся по массиву $this->rel_items и удаляем привязанные модели			foreach($this->rel_items as $rel_item){				$rel_item->delete();			}			//получаем объект модели			$obj_model=gmo($this->__name__);			//чтобы не делать лишнего запроса к БД получаем данные элемента модели в массив			foreach(get_object_vars($obj_model) as $field_name=>$obj_field){				if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){					$model_item_data[$field_name]=$this->$field_name;				}			}			//для каждого поля вызывается метод beforeDelete() c данными удаляемого элемента модели			foreach(get_object_vars($obj_model) as $field_name=>$obj_field){				if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){					$obj_field->beforeDelete($model_item_data);				}			}			//исполняется sql-запрос, удаляющий элемент			$dbq=new DBQ('delete from `'.$this->__name__.'` where id=?',$this->id);			//запускаем afterDelete()			$this->afterDelete();			//запускаем afterChange()			$this->afterChange();			unset($this);		}		return $err_relations;	}	function checkModelItemRelations(){		/*		 проверяем связи текущего элемента модели с другими моделями		 и либо вовращаем $linked_model_items_arr (массив ссылок на привязанные элементы),		 либо ничего не возвращаем, если связей нет, или если __admin__['delete_rel']===true		 */		if(!$this->__item__){_die('метод checkModelItemRelations() может быть вызван только элементом модели');}		$self_obj_model=gmo($this->__name__);		//чтобы отследить связи со всеми моделями, нам нужно создать объекты всех моделей		$obj_model_arr=$this->_getAllModelObjectsArr();		//обозначаем массив для хранения привязанных моделей, чтобы впоследствие можно было их удалить		$this->rel_items=array();		//сначала нужно пройти по всем полям всех моделей (кроме текущей) в поисках ForeignKey		if(is_array($obj_model_arr) && count($obj_model_arr)>0){			foreach($obj_model_arr as $suspected_model_name=>$suspected_obj_model){				if($suspected_model_name==$this->__name__){continue;}//_echo($suspected_model_name);				foreach(get_object_vars($suspected_obj_model) as $field_name=>$obj_field){					if(is_a($obj_field,'ForeignKeyField') && $obj_field->getRelModelName()==$this->__name__){						//_print_r($obj_field);						//к этому моменту известно, что у модели $suspected_model_name есть поле $field_name						//которое смотрит на удаляемую модель						//теперь нужно найти id всех элементов данной модели, у которых $field_name=$this->id						$items_arr=ga(array(							'classname'=>$suspected_model_name,							'fields'=>'id',							'filter'=>$field_name.'='.$this->id,//строка фильтра типа 'parent=32'							'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)						));						//теперь либо получаем массив сcылок, либо удаляем элементы						foreach($items_arr as $item){							if($self_obj_model->__admin__['delete_rel']===true){								$this->rel_items[]=new $suspected_model_name($item['id']);							}else{								$result[]='<a href="/admin/'.$suspected_model_name.'/edit/?'.$suspected_model_name.'[id]='.$item['id'].'">['.$suspected_obj_model->__str__(gbi($suspected_model_name,$item['id'])).']</a>';							}						}					}elseif(is_a($obj_field,'ManyToManyField') && $obj_field->getRelModelName()==$this->__name__){						//известно, что модель $suspected_obj_model имеет поле $obj_field типа ManyToManyField						//которое смотрит на удаляемую модель.						//проверяем нет ли у удаляемой модели аналогичной связи с $suspected_obj_model						//и если есть, то не предпринимаем никаких действий						if($this->_checkSameManyToManyField($suspected_model_name)){continue;}						//теперь нужно найти id всех элементов модели $suspected_obj_model,						//которые привязаны к удаляемому элементу						$dbq=new DBQ('select `@` as id from `@` where `@`=?'						,$suspected_model_name.'_id_key1'						,$obj_field->_getRelTableName()						,$this->__name__.'_id_key2'						,$this->id						);						if($dbq->rows>0){							//теперь либо получаем массив сcылок, либо удаляем элементы							foreach($dbq->items as $item){								if($self_obj_model->__admin__['delete_rel']){									$dbq=new DBQ('delete from @ where @=?'									,$obj_field->_getRelTableName()									,$this->__name__.'_id_key2'									,$this->id									);								}else{									$result[]='<a href="/admin/'.$suspected_model_name.'/edit/?'.$suspected_model_name.'[id]='.$item['id'].'">['.$suspected_obj_model->__str__(gbi($suspected_model_name,$item['id'])).']</a>';								}							}						}					}				}			}		}else{_die('empty array $suspected_obj_model_arr in checkModelItemRelations()');}		if(isset($result)){			return $result;		}	}	function moveUp(){		$move=($this->_orderingIsDirect())?'up':'down';		return $this->_moveUpDown($move);	}	function moveDown(){		$move=($this->_orderingIsDirect())?'down':'up';		return $this->_moveUpDown($move);	}	function _orderingIsDirect(){		/*			предположим, что ordering='parent,-ordering'			в этом случае нам нужно искать '-ordering'			*/		//модель элемента		$obj_model=gmo($this->__name__);		//строка с сортировкой		$string=$obj_model->__admin__['ordering'];		unset($obj_model);		//вытаскиваем объект поля сортировки		$obj_order_field=$this->_getOrderFieldObj();		//определяем название поля		$db_column=$obj_order_field->db_column;		unset($obj_order_field);		//искомая подстрока		$search_string='-'.$db_column;		if(mb_strpos($string,$search_string)===false){			//искомая подстрока не найдена, значит порядок прямой			$result=true;		}else{			$result=false;		}		return $result;	}	function errReport($errors_arr){		if(!$this->__item__){_die('метод errReport() может быть вызван только элементом модели');}		if(is_array($errors_arr) && count($errors_arr)>0){			$result=array();			foreach($errors_arr as $field_name=>$error_type){				$result[]=sprintf('— %s',$this->errReportMessage($error_type,$field_name));			}			if( !empty($result) ){				$result=implode('<br>',$result);				return $result;			}		}	}		function errReportMessage($error_type,$field_name){		if(!$this->__item__){_die('метод errReport() может быть вызван только элементом модели');}		$obj_model=gmo($this->__name__);		switch ($error_type) {			case 'blank':				$result=sprintf('не заполнено поле «%s»',$obj_model->$field_name->txt_name);				break;			case 'match':				if( is_subclass_of($obj_model->$field_name, 'FileField') ){					$result=sprintf('файл в поле «%s» не соответствует формату',$obj_model->$field_name->txt_name);				}else{					$result=sprintf('поле «%s» не соответствует шаблону %s',$obj_model->$field_name->txt_name,$obj_model->$field_name->match);				}				break;			case 'sizes':				$result=sprintf('размеры изображения «%s» не соответствуют ожидаемым (%s)',$obj_model->$field_name->txt_name,$this->_expectedImageSizes($obj_model->$field_name->sizes));				break;			case 'unique':				$result=sprintf('поле %s со значением  «%s» уже имеется в БД',$obj_model->$field_name->txt_name,$this->$field_name);				break;			case 'wrong':				$result=sprintf('поле «%s» заполнено некорректно',$obj_model->$field_name->txt_name);				break;			case 'loading':				$result=sprintf('файл в поле «%s» не загружен из-за большого размера',$obj_model->$field_name->txt_name);				break;			default:				$result=$error_type;		}		return $result;	}	function validate(){}//вызывается перед save()	function beforeChange(){}//вызывается ДО добавления, редактирования и удаления элемента модели и перед всеми оставльными before-функциями	function beforeAdd(){}//вызывается ДО добавления нового элемента модели	function beforeEdit(){}//вызывается ДО редактирования элемента модели	function beforeDelete(){}//вызывается ДО удаления элемента модели	function afterAdd(){}//вызывается после добавления нового элемента модели	function afterEdit(){}//вызывается после редактирования элемента модели	function afterDelete(){}//вызывается после удаления элемента модели	function afterChange(){}//вызывается после добавления, редактирования и удаления элемента модели и по_сле всех остальных after-функций	//=================================================================	function _getAllModelObjectsArr(){		//массив $GLOBALS['INSTALLED_APPS'] уже должен быть загружен,		//поскольку он загружается во время создания любой модели, в том числе и текущей		if(is_array($GLOBALS['INSTALLED_APPS']) && count($GLOBALS['INSTALLED_APPS'])>0){			$result=array();			foreach($GLOBALS['INSTALLED_APPS'] as $model_name=>$model_txt_name){				//создаем экземпляр модели				$obj_model=gmo($model_name);				$result[$model_name]=$obj_model;			}		}else{_die('empty INSTALLED_APPS array');}		return $result;	}	function _getSQLQueryPairs(){		//здесь мы должны пройтись по тем полям модели,		//которые были инициализированы,		//чтобы запустить обработчик данных каждого поля		$result='';		$obj_model=gmo($this->__name__);		foreach(get_object_vars($obj_model) as $field_name=>$obj_field){			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				if( is_a($obj_field,'PrimaryKeyField') || is_a($obj_field,'ManyToManyField') ){					continue;				}elseif( is_a($obj_field,'FileField') || is_subclass_of($obj_field,'FileField') ){					$path2file=defvar($this->$field_name,$this->_input[$field_name]);					// оставляем в элементе значение, равное новому названию файла (без пути)					$this->$field_name=$obj_field->getModelItemInitValue(array('_relkey'=>$this->_input['_relkey'],'path2file'=>$path2file));					// в метод ->getSQLupdate() передаем путь к файлу $path2file					$result.=$obj_field->getSQLupdate(array('_relkey'=>$this->_input['_relkey'],'path2file'=>$path2file));				}elseif( is_a($obj_field,'YamapField') || is_a($obj_field,'GmapField') ){					$coords=defvar($this->$field_name,$this->_input[$field_name]);					// проверяем правильность переданных координат и оставляем в элементе полученное значение					$this->$field_name=$obj_field->getModelItemInitValue(array('_relkey'=>$this->_input['_relkey'],'coords'=>$coords));					// в метод ->getSQLupdate() передаем значение, полученное из ->getModelItemInitValue()					$result.=$obj_field->getSQLupdate($this->$field_name);				}else{					$result.=$obj_field->getSQLupdate($this->$field_name);				}			}		}		//_echo($result);		$result=mb_substr($result,0,-1);		if(isset($result)){			return $result;		}	}		function _validateRemoveTags(){		// _log('_validateRemoveTags');		$obj_model=gmo($this->__name__);		foreach(get_object_vars($obj_model) as $field_name=>$obj_field){			// _log('$field_name',$field_name);			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				// _log('$obj_field->allowtags, $obj_field->blank, $obj_field->editable',$obj_field->allowtags, $obj_field->blank, $obj_field->editable);				if($obj_field->allowtags){continue;}				$field_value=$this->$field_name;				// _log('$field_value',$field_value);				$this->$field_name=strip_tags($field_value);				// _log('$this->$field_name',$this->$field_name);			}		}	}	function _validateFieldsDataPresence(){		$obj_model=gmo($this->__name__);		foreach(get_object_vars($obj_model) as $field_name=>$obj_field){			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				// если это файл или изображение, то проверяем загрузку файла				// независимо от обязательности				if( is_a($obj_field,'FileField') || is_subclass_of($obj_field,'FileField') ){					$path2file=defvar($this->$field_name,$this->_input[$field_name]);					if( !$obj_field->_checkLoading(array('_relkey'=>$this->_input['_relkey'],'path2file'=>$path2file)) ){						$result[$field_name]='loading';					}				}				//пропускаем поля с blank==true				if($obj_field->blank){continue;}				//пропускаем поля с editable==false если id>0, потому что такие поля должны уже быть заполнены				if($this->id>0 && !$obj_field->editable){continue;}				//пропускаем поля CaptchaField, потому что для них проверка осуществляется после validate()				if(is_a($obj_field,'CaptchaField')){continue;}				// для FileField и его наследников проверка иная				if( is_a($obj_field,'FileField') || is_subclass_of($obj_field,'FileField') ){					$path2file=defvar($this->$field_name,$this->_input[$field_name]);					$field_value=$obj_field->getModelItemInitValue(array('_relkey'=>$this->_input['_relkey'],'path2file'=>$path2file));					if( $field_value==='' ){						$result[$field_name]='blank';					}				}elseif( is_a($obj_field,'YamapField') || is_a($obj_field,'GmapField') ){					$coords=defvar($this->$field_name,$this->_input[$field_name]);					$field_value=$obj_field->getModelItemInitValue(array('_relkey'=>$this->_input['_relkey'],'coords'=>$coords));					if( $field_value==='' ){						$result[$field_name]='blank';					}				}elseif( is_a($obj_field,'ForeignKeyField') ){					if( intval($this->$field_name)==0 ){						$result[$field_name]='blank';					}				}else{					// проверяем есть ли значение у поля					if( $this->$field_name==='' || $this->$field_name=='__null_option__' ){						$result[$field_name]='blank';					}				}			}		}		if(isset($result)){			return $result;		}	}	function _validateFieldsDataCorrespondence(){		$input_data=$this->_getInputDataToValidate();		$obj_model=gmo($this->__name__);		foreach(get_object_vars($obj_model) as $field_name=>$obj_field){			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				if( is_a($obj_field,'FileField') || is_subclass_of($obj_field,'FileField') ){					// соответствует ли файл указанному формату					$path2file=defvar($this->$field_name,$this->_input[$field_name]);					if( !$obj_field->_checkMatching(array('_relkey'=>$this->_input['_relkey'],'path2file'=>$path2file)) ){						$result[$field_name]='match';					}					// соответствует ли изображение указанным размерам					if( is_a($obj_field,'ImageField') && !$obj_field->_checkUploadedImageSize(array('_relkey'=>$this->_input['_relkey'],'path2file'=>$path2file)) ){						$result[$field_name]='sizes';					}				}else{					if( $obj_field->blank && $input_data[$field_name]==='' ){continue;}					//пропускаем поля CaptchaField, потому что для них проверка осуществляется после validate()					if(is_a($obj_field,'CaptchaField')){continue;}					if(isset($obj_field->match) && $input_data[$field_name]!==''){						//пропускаем поля с blank=true, если они равны пустому значению						//_echo($obj_field->match);_echo($input_data[$field_name]);_echo(preg_match($obj_field->match,$input_data[$field_name]));chb(preg_match($obj_field->match,$input_data[$field_name]));						if( ! preg_match($obj_field->match,$input_data[$field_name]) ){							$result[$field_name]='match';						}					}elseif(is_a($obj_field,'EmailField')){						if( !validateEmail($input_data[$field_name]) ){							$result[$field_name]='match';						}					}elseif(is_a($obj_field,'URLField')){						if( !validateUrl($input_data[$field_name]) ){							$result[$field_name]='match';						}					}				}				//проверяем уникальность				if($obj_field->unique){					$mmanager=$this->objects();					$mmanager=$mmanager->fields('id');					//ДОБАВЛЯЕМ В ФИЛЬТР УСЛОВИЯ:					//уникальное поле равно переданному значению					$value=$input_data[$obj_field->db_column];					if( $obj_field->maxlength ){						$value=mb_substr($value,0,$obj_field->maxlength);					}					$mmanager=$mmanager->filter($this->_getValidateUniqueFlter($field_name,$value));					//id не равен текущему значению, чтобы исключить текущую запись					if(isset($input_data['id'])){						$mmanager=$mmanager->filter($this->_getValidateUniqueIdFlter($input_data['id']));					}					//сопутствующие поля равны переданным значениям					if($obj_field->fieldrel!=''){						$mmanager=$mmanager->filter($this->_getValidateUniqueRelFlter($obj_field->fieldrel,$input_data));					}					$model_element=$mmanager->_slice(0,1);					if(!empty($model_element[0])){						$result[$field_name]='unique';					}				}			}		}//_echo('rest');		if(isset($result)){			return $result;		}	}	function _getOrderForModelTableQuery(){		$result=trim(defvar('id',$this->__admin__['ordering']));		return $result;	}	function _getOrderFieldName(){		$order_by=$this->_getOrderForModelTableQuery();		$order_field=$order_by;		$order_field=str_replace('-','',$order_field);		$order_field=str_replace('+','',$order_field);		$result=$order_field;		return $result;	}	function _getFieldsListForModelTableQuery($group_field=''){		//пробегаем по массиву __admin__['list_display']		if(isset($this->__admin__['list_display'])){			if(is_array($this->__admin__['list_display']) && count($this->__admin__['list_display'])>0){				$list_display_string=implode(',',$this->__admin__['list_display']);			}elseif(is_string($this->__admin__['list_display'])){				$list_display_string=$this->__admin__['list_display'];			}		}else{			$list_display_string='*';		}		if($group_field && $list_display_string!='*'){			$list_display_string.=','.$group_field;		}		return $list_display_string;	}	function _getFilterForModelTableQuery(){		if(isset($this->__admin__['filter'])){			$result=$this->__admin__['filter'];		}else{			$result='1';		}		return $result;	}	function _getTypeFilter(){		if(p2v('tf')){			$tf=defvar($this->__admin__['type_filter'],$this->__admin__['tf']);			if($tf){				if( !is_array($tf) ){					$tf=_explode($tf);				}				$result=array();				foreach($tf as $item){					$model__field=explode('.',$item);					if( count($model__field)==2 ){						$model_name=$model__field[0];						$field_name=$model__field[1];						// нужно осуществить поиск по полю $field_name в модели $model_name						// и затем передать результаты поиска в текущую модель						$model_obj=gmo($model_name);						if( is_subclass_of( $model_obj->$field_name, 'Field' ) ){							$ids=$model_obj->ga(array(								'fields'=>'id',//список полей которые нужно вытащить через запятую 'id,name,body'								'filter'=>e5csql('`@` like "%@%"', $field_name, mysql_escape_string(p2v('tf'))),//строка фильтра типа 'parent=32'								'_slice'=>array(0),//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)							));							if( !empty($ids) ){								$ids=kgi('id',$ids);								// определяем к какому полю текущей модели привязана модель $model_obj								foreach(get_object_vars($this) as $field_name=>$obj_field){									if( is_a($obj_field,'ForeignKeyField') && $obj_field->getRelModelName()==$model_name ){										$result[]=e5csql('`@` in (@)', $obj_field->db_column, $ids);										break;									}								}							}						}					}else{						$result[]=e5csql('`@`.`@` like "%@%"', $this->__name__, $item, mysql_escape_string(p2v('tf')));					}				}				$result=implode(' or ',$result);			}		}else{			$result='1';		}		return $result;	}	function _getGroupFilter($parent_id='',$year=0,$month=0){		$group_field=(isset($this->__admin__['group']))?$this->__admin__['group']:'';		if($group_field){			if(is_a($this->$group_field,'DateField') || is_a($this->$group_field,'DateTimeField') || is_a($this->$group_field,'TimestampField')){				$result='year(`'.$this->__name__.'`.`'.$group_field.'`)='.(int)$year;				$result.=' and month(`'.$this->__name__.'`.`'.$group_field.'`)='.(int)$month;				return $result;			}else{				if($parent_id!==''){					return '`'.$this->__name__.'`.`'.$group_field.'`='.(int)$parent_id;				}			}			//if(is_a($this->$group_field,'DateField') || is_a($this->$group_field,'DateTimeField'))		}	}	/*function _getDomainOrMultiFilter(){		$result=1;		if(is_a($this->domain,'DomainField')){		if(is_a($this->multidomain,'BooleanField')){		$result='(domain="'.DOMAIN_ID.'" or multidomain="yes")';		}else{		$result='domain="'.DOMAIN_ID.'"';		}		}		return $result;		}*/	function _getSQLmethodForSaveModelItem(){		if( $this->id ){			// запоминаем ID исходного элемента, чтобы вытащить о нем некоторые данные из БД			define('ORIGINAL_ITEM_ID',$this->id);		}		if(!empty($_POST['copy'])){			// если происходит копирование, то нужно делать insert			$result='insert';			define('COPY_PROCESS',true);		}else{			$result=($this->id && $this->mdate)?'update':'insert';		}		return $result;	}	function _reloadAfterParseringPostedData($id){		//в зависимости от того, какая была нажата кнопка, показываем форму или список		if(p2v('save_then_exit')!='' || p2v('delete')!=''){			$location='/admin/'.$this->__name__.'/';		}elseif(p2v('save_then_add')!=''){			$location='/admin/'.$this->__name__.'/edit/';		}else{			$location='/admin/'.$this->__name__.'/edit/?'.$this->__name__.'[id]='.$id;		}		//добавляем параметр type filter		if(p2v('tf')){			if(mb_substr($location,-1)=='/'){				$location.='?tf='.p2v('tf');			}else{				$location.='&tf='.p2v('tf');			}		}		header('Location:'.DOMAIN_PATH.$location);	}	function _doesModelsTableExists(){		$dbq=new DBQ('show tables like "'.$this->__name__.'"');//_echo($dbq->query);		$result=(bool)$dbq->rows==1;		return $result;	}	function _getModelsTableDbColumnsInfo(){		$dbq=new DBQ('show columns from `'.$this->__name__.'`');		$columns_data=$dbq->items;		if(is_array($columns_data)){			$result=array();			foreach($columns_data as $column){				$result[$column['Field']]=$column;			}		}		return $result;	}	function _performModelItemSave(){		//_log('_performModelItemSave for model '.$this->__name__);		if(!$this->__item__){_die('метод performModelItemSave() может быть вызван только элементом модели');}		//определяем какой мы будем выполнять метод: insert или update		$method=$this->_getSQLmethodForSaveModelItem();//_log('$method='.$method);		$this->beforeChange();		switch($method){			case 'insert':				$this->beforeAdd();				$dbq=new DBQ('insert into `'.$this->__name__.'` set @',				$this->_getSQLQueryPairs()				);				$dbq=new DBQ('select last_insert_id() as item_id');				$this->id=$dbq->item;				// сохраняем данные полей ManyToManyField и On eToManyField				$this->_performMTMFieldSave();				// в процессе создания не может быть привязанных моделей evpozdniakov@26112010				// $rel_errors_arr=$this->_performRelModelItemsSave();				$this->afterAdd();				break;			case 'update':				$this->beforeEdit();				$dbq=new DBQ('update `'.$this->__name__.'` set @ where `'.$this->__name__.'`.id=?',				$this->_getSQLQueryPairs(),				$this->id				);				//сохраняем данные полей ManyToManyField и OneToManyField				$this->_performMTMFieldSave();				//сохраняем привязанные модели если есть				$rel_errors_arr=$this->_performRelModelItemsSave();				$this->afterEdit();				break;		}		$this->afterChange();		return $rel_errors_arr;	}	function _performMTMFieldSave(){		$obj_model=gmo($this->__name__);		foreach(get_object_vars($obj_model) as $field_name=>$obj_field){			if( is_object($obj_field) && is_a($obj_field,'ManyToManyField') ){				$init_values=defvar($this->$field_name,$this->_input[$field_name]);				// возможно, что поле не является редактируемым $obj_field->editable==false				// если так, то не нужно вносить изменения, иначе данные пропадут				if( EDIT_MODE===true && $obj_field->editable===false ){continue;}				$obj_field->performFieldDataSave($this->id,$init_values);			}		}	}	function _performRelModelItemsSave(){		// на случай, если привязанная модель имеет только поля типа file		// копируем ключи из массива $_FILES в массив $_POST		foreach(array_keys($_FILES) as $key){			if( !array_key_exists($key, $_POST) ){				$_POST[$key]=array();			}		}		// осуществляем запись привязанных моделей только если		// находимся в админке на странице редактирования текущей модели		// (чтобы исключить случайную запись прив. мод. например		// в результате вызова метода ->save() другой модели)		if( $GLOBALS['path_requested'][2]!=$this->__name__ ){return;}		//нужно выяснить какая модель связана с текущей		//воспользуемся методом _getRelFieldsArr()		$rel_fields_arr=$this->_getRelFieldsArr();//_print_r($rel_fields_arr);		//_log('$rel_fields_arr');		//_log(export($rel_fields_arr));		// инициализируем массив, который запомнит ошибки, если они произошли в привязанных моделях		$rel_errors_arr=array();		if(is_array($rel_fields_arr)){			foreach($rel_fields_arr as $field){				$rel_model_name=$field->model_name;				//на сей момент нам известно, что к текущей модели привязана модель $rel_model_name				//разбираем $_POST и вытаскиваем данные этой модели				//_log(export($_POST));				foreach($_POST as $key=>$post_data){					$rel_model_item_id=false;					//например, если модель 'support', то ищем					//в ключе $key подстроку support_new[0-9]+ или support_[0-9]+					//сначала пытаемся найти новые элементы (ищем подстроку с "_new")					$substr=$rel_model_name.'_new';					//_log('ищем в ключе '.$key.' подстроку '.$substr.'');					if(mb_strpos($key,$substr)===0){						//получаем целое число [0-9]+, которое следует за подстрокой support_new						$number=(int)mb_substr($key,mb_strlen($substr));						//соединяем подстроку и полученное целое, сравниваем с ключом						if($substr.$number==$key){							//теперь мы можем с точностью заявить, что в массиве $_POST							//были переданы данные для создания нового элемента							$rel_model_item_id='new';						}					}else{						//если новые элементы не найдены,						//пытаемся найти старые элементы (ищем подстроку с "_")						$substr=$rel_model_name.'_';						if(mb_strpos($key,$substr)===0){							//получаем целое число [0-9]+, которое следует за подстрокой support_new							$number=(int)mb_substr($key,mb_strlen($substr));							//соединяем подстроку и полученное целое, сравниваем с ключом							if($substr.$number==$key){								//теперь мы можем с точностью заявить, что в массиве $_POST								//были переданы данные для редактирования элемента $number								$rel_model_item_id=$number;							}						}					}					if($rel_model_item_id){						//если $rel_model_item_id==0, то мы должны создать новый элемент						//иначе обновить поля имеющегося						if($rel_model_item_id=='new'){							// если в $_POST и в $_FILES отсутствуют данные для элемента							// то переходим к следующему							if( !$this->_relModelNewItemDataPresented($key, $rel_model_name) ){continue;}							//создаем массив для инициализации элемента модели							$init_arr=array(								'id'=>$rel_model_item_id,								$field->db_column=>$this->id,							);							$init_arr=_array_merge($init_arr,$post_data);							//_log('создаем массив для инициализации элемента модели');							//_log(export($init_arr));						}elseif($post_data['__delete__']=='on'){							//возможно, что элемент пожелали удалить							//создаем элемент с id=$rel_model_item_id и удаляем его							$rel_model_item=new $rel_model_name($rel_model_item_id);							//_log('$rel_model_item');//_log(export($rel_model_item));							$rel_model_item->delete();							continue;						}else{							//_log('вытаскиваем массив полей элемента с id='.$rel_model_item_id.'');							//вытаскиваем массив полей элемента с id=$rel_model_item_id							$init_arr=gbi($rel_model_name,$rel_model_item_id);							//_log(export($init_arr));							//изменяем поля согласно данным из $_POST							//_log('изменяем поля согласно данным из $_POST');							//_log('$rel_model_name='.$rel_model_name);							$rel_model_obj=gmo($rel_model_name);							foreach(get_object_vars($rel_model_obj) as $field_name=>$obj_field){								if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){									if($obj_field->core && $obj_field->editable){										//_log('->core && ->editable $field_name='.$field_name);										if(is_a($obj_field,'BooleanField') && !array_key_exists($field_name,$post_data)){											//если в post-е нет поля BooleanField, значит передано значение 'no'											$init_arr[$field_name]=$obj_field->getModelItemInitValue(array('init_values'=>array($field_name=>'no')));										}else{											$init_arr[$field_name]=$obj_field->getModelItemInitValue(array('init_values'=>$post_data));										}									}								}							}							//_log(export($init_arr));						}						//напоследок добавляем в массив $init_arr поле _relkey, которое						//обозначит принадлежность модели к другой модели						$init_arr['_relkey']=$key;						//_echo('init array here');_print_r($init_arr);						//создаем и тут же сохраняем элемент модели						//_print_r($init_arr);_die('------');						$rel_model_item=new $rel_model_name($init_arr);						$errors_arr=$rel_model_item->save();						if( !empty($errors_arr) ){							$rel_errors_arr[$rel_model_name]=$rel_model_item->errReport($errors_arr);						}					}				}			}		}		return $rel_errors_arr;	}	function _relModelNewItemDataPresented($key, $rel_model_name){		$rel_model_obj=gmo($rel_model_name);		foreach(get_object_vars($rel_model_obj) as $field_name=>$obj_field){			if( is_object($obj_field) && is_subclass_of($obj_field,'Field') ){				if( !$obj_field->blank && array_key_exists($field_name,$_POST[$key]) ){					$value=$_POST[$key][$field_name];					if( !empty($value) && $value!='__null_option__'  ){						if( $value!=$obj_field->default ){							return true;						}					}				}			}		}		if( is_array($_FILES[$key]) && is_array($_FILES[$key]) ){			$tmp_names=array_values($_FILES[$key]['tmp_name']);			$tmp_names=implode('',$tmp_names);			if( !empty($tmp_names) ){				return true;			}		}		return false;	}		function _loadLastSavedModelItem($item_id){		if(!$this->__item__){_die('метод _loadLastSavedModelItem() может быть вызван только элементом модели');}		if(!isset($this->id)){			$this->id=$item_id;		}		//получаем объект модели		$obj_model=gmo($this->__name__);		//получаем данные из БД для текущего элемента		$data=$obj_model->objects();		$data=$data->_get($this->id);		//устанавливаем значения из БД взамен имеющихся у элемента		if(is_array($data) && count($data)>0){			foreach($data as $key=>$value){				$this->$key=$value;			}		}else{/*_die('empty array $data in _loadLastSavedModelItem');*/}	}	/**	 * добавил аргумент $validate_all_fields=false	 * потому что в какой-то момент понадобилось получить все ошибки, 	 * которые возникнут при создании элемента модели	 * $item=gmi('classname',$data);	 * $errors=$item->_validateModelItemFieldsData(true);	 * без этого аргумента возвращались только те ошибки, 	 * которые определялись в методе ->validate() модели	 */	function _validateModelItemFieldsData($validate_all_fields=false){		if(!$this->__item__){_die('метод _validateModelItemFieldsData() может быть вызван только элементом модели');}		// убираем теги, если они не допускаются		$this->_validateRemoveTags();		// определяем		if( !isset($GLOBALS['skip_validation']) ){			$GLOBALS['skip_validation']=array();		}		$GLOBALS['skip_validation'][$this->__name__]=false;		//запускаем внутреннюю валидацию модели		$validate_self_errors=$this->validate();		if(empty($validate_self_errors) || $validate_all_fields===true){			if( !$GLOBALS['skip_validation'][$this->__name__] ){				// проверяем присутствие обязательных полей, отбрасываем лишние поля,				// если таковые затесались каким-то образом				$validate_model_errors=$this->_validateFieldsDataPresence();//_print_r($validate_model_errors);				if(empty($validate_model_errors)){					//проверяем соответствие данных типам полей					$validate_model_errors=$this->_validateFieldsDataCorrespondence();				}			}		}		$errors_arr=_array_merge($validate_self_errors,$validate_model_errors);		if(empty($errors_arr)){			/*				запускаем проверку captcha для клиентской части				проверку каптчи нужно вызывать уже после того, как отработал метод validate() текущей модели,				для того, чтобы другие проверки осуществлялись до "проверки на робота", и не мешали пользователю				заполнять форму				*/			if($GLOBALS['path'][1]!='admin'){				$obj_model=gmo($this->__name__);				foreach(get_object_vars($obj_model) as $field_name=>$obj_field){					if(is_a($obj_field,'CaptchaField') && !$obj_field->blank){						if($_SESSION['captcha_keystring']!=$this->$field_name){							$errors_arr[$field_name]='wrong';						}else{							unset($_SESSION['captcha_keystring']);						}						break;					}				}			}		}		return $errors_arr;	}	function _getPostedModelItemDataArr($model_item_data){		if(!$this->__item__){_die('метод _getPostedModelItemDataArr() может быть вызван только элементом модели');}		// перебираем переданные поля POST-а		$post=$_POST[$this->__name__];		foreach($post as $key=>$value){			//если в массиве $model_item_data присутствует текущий ключ,			//то переопределяем значение			if(array_key_exists($key,$model_item_data)){				$model_item_data[$key]=$value;			}		}		return $model_item_data;	}	function _getRelFieldsArr(){		$result=array();		$obj_model_arr=$this->_getAllModelObjectsArr();//_print_r(array_keys($obj_model_arr));		if(is_array($obj_model_arr)){			//перебираем все модели кроме самой себя			foreach($obj_model_arr as $model_name=>$obj_model){				if(!is_object($obj_model)){_die('модель "'.$model_name.'" не загружена');}				//пропускаем саму себя				if($model_name==$this->__name__){continue;}//_echo($model_name);				foreach(get_object_vars($obj_model) as $field_name=>$obj_field){					if(is_a($obj_field,'ForeignKeyField')){						//получаем название привязанной модели						$foreign_model_name=$obj_field->getRelModelName();						if($foreign_model_name==$this->__name__){							$result[]=$obj_field;						}					}				}			}		}		return $result;	}	function _getOrderFieldObj(){		$result=null;		$obj_model=gmo($this->__name__);		foreach(get_object_vars($obj_model) as $field_name=>$obj_field){			if(is_a($obj_field,'OrderField')){				$result=$obj_field;				break;			}		}		return $result;	}	function _moveUpDown($move){		if(!$this->__item__){_die('метод _moveUpDown() может быть вызван только элементом модели');}		//нужно вытащить поле типа OrderField		$obj_order_field=$this->_getOrderFieldObj();		if(!isset($obj_order_field)){_die('в модели отсутствует поле типа OrderField');}		//_print_r($obj_order_field);		//прежде чем производить сортировку нужно убедиться, что поле сортировки заполнено данными отличными от нуля		$this->_checkOrderingData($obj_order_field);		$db_column=$obj_order_field->db_column;		//_echo('$db_column:'.$db_column);		if(isset($obj_order_field->fieldrel)){			$rel=explode(',',$obj_order_field->fieldrel);			$filter='1';			foreach($rel as $item){				$filter.=e5csql(' and `@`=?',$item,$this->$item);			}		}		//_echo('$rel:'.$rel);		//нужно вытащить рядом стоящий элемент модели - предыдущий		$mmanager=$this->objects();		$mmanager=$mmanager->filter($filter);		$lt_gt=($move=='up')?'<':'>';		$mmanager=$mmanager->filter($db_column.$lt_gt.$this->$db_column);		$plus_minus=($move=='up')?'-':'+';		$mmanager=$mmanager->order_by($plus_minus.$db_column);		$next_element=$mmanager->_slice(0,1);		if(!empty($next_element[0])){			//_echo('$next_element[0] found');			//если есть элемент с которым можно поменяться местами, то меняем			$dbq=new DBQ('update `@` set @=? where id=?',$this->__name__,$db_column,$this->$db_column,$next_element[0]['id']);			$dbq=new DBQ('update `@` set @=? where id=?',$this->__name__,$db_column,$next_element[0][$db_column],$this->id);			if($this->__name__=='_modelsfields'){				$this->afterChange($up__down=true);			}			return $next_element[0]['id'];			/*			 раньше было так, но обнаружилось, что на баннерах в корбине сортировка не работает.			 причина оказалась в обязательной картинке - метод save() не выполнялся из-за того,			 что в элементе модели, полученном с помощью new, поле picure - пустое			 по нормальному нужно переделать метод FileField->getModelItemInitValue(), чтобы			 он в таких случаях возвращал в поле picture название имеющейся картинки			 $next_element_obj=new $this->__name__($next_element[0]['id']);			 $next_element_obj->set($db_column,$this->$db_column);			 $next_element_obj->save();			 $this->set($db_column,$next_element[0][$db_column]);			 $this->save();			 //_echo('$next_element_obj-');			 //_print_r($next_element_obj);			 //_echo('this');			 //_print_r($this);			 */		}else{			return false;		}	}	function _checkOrderingData($obj_order_field){		$db_column=$obj_order_field->db_column;		if(isset($obj_order_field->fieldrel)){			$rel=explode(',',$obj_order_field->fieldrel);			$filter='1';			foreach($rel as $item){				$filter.=e5csql(' and `@`=?',$item,$this->$item);			}		}		//получаем объект модели		$obj_model=gmo($this->__name__);		//нам нужно удостовериться, что количество всех элементов равно		//количеству элементов с группировкой по полю сортировки.		//таким образом мы сможем выявить одинаковые значения в поле сортировки		//и сделать пересортировку		$mmanager=$obj_model->objects();		$mmanager=$mmanager->fields('id');		if(isset($filter)){			$mmanager=$mmanager->filter($filter);		}		$count1=count($mmanager->_slice(0));//_echo($mmanager->query);		if(isset($filter)){			$mmanager=$mmanager->extra(array('where'=>''.$filter.' group by `'.$db_column.'`'));		}else{			$mmanager=$mmanager->extra(array('where'=>'1 group by `'.$db_column.'`'));		}		$count2=count($mmanager->_slice(0));//_echo($mmanager->query);		if($count1!=$count2){			//пересортировка			$mmanager=$obj_model->objects();			$mmanager=$mmanager->fields('id');			if(isset($filter)){				$mmanager=$mmanager->filter($filter);			}			$mmanager=$mmanager->order_by($db_column);			$id_list=$mmanager->_slice(0);//_print_r($id_list);			$num=0;			foreach($id_list as $item){				$num++;				$dbq=new DBQ('update `'.$this->__name__.'` set `'.$db_column.'`=? where id=?',$num,$item['id']);			}		}	}	function _getValidateUniqueFlter($db_column,$value){		$result=sprintf('`%s`="%s"', $db_column, $value);		return $result;	}	function _getValidateUniqueIdFlter($id=0){		$result=sprintf('`id`!="%d"', $id);		return $result;	}	function _getValidateUniqueRelFlter($rel_arr,$input_data){		$result='1';		$rel_arr=explode(',',$rel_arr);		foreach($rel_arr as $db_column){			$field_data=$input_data[$db_column];			$result.=sprintf(' and `%s`="%s"', $db_column, $field_data);		}		return $result;	}	function _getInputDataToValidate(){		// я повторно переделал эту констукцию		// очень ee упростил — решил возвращать значения всех полей, если они строки		foreach($this as $key=>$value){			if(is_string($value)){				$result[$key]=$value;			}		}		return $result;	}	function _expectedImageSizes($sizes){		$sizes=explode('/',$sizes);		if($sizes[0]!='' && $sizes[1]!=''){			$result=$sizes[0].'x'.$sizes[1].' пикселей';		}elseif($sizes[0]!=''){			$result='ширина '.$sizes[0].', высота любая';		}elseif($sizes[1]!=''){			$result='ширина любая, высота '.$sizes[1];		}		return $result;	}	function _checkSameManyToManyField($rel_model_name){		$result=false;		foreach(get_object_vars($this) as $field_name=>$obj_field){			if(is_a($obj_field,'ManyToManyField') && $obj_field->getRelModelName()==$rel_model_name){				$result=true;				break;			}		}		return $result;	}	function _getForeignModel($field_name){		//получаем объект поля, которое является группирующим		$obj_field=$this->$field_name;		//получаем название группирующей модели (на которую смотрит ForeignKey)		$foreign_model_name=$obj_field->getRelModelName();		//получаем объект группирующей модели		$obj_foreign_model=gmo($foreign_model_name);		return $obj_foreign_model;	}	function _getMatchBracePosition($str, $open_brace_position){		//_echo(e5c($str));		//_echo('['.$open_brace_position.']');_echo('['.mb_substr($str,$open_brace_position,1).']');		//_echo(mb_substr($str,$open_brace_position,100));		//определяем символ открывающей скобки и соответствующей закрывающей скобки		$open_brace=mb_substr($str,$open_brace_position,1);		if($open_brace=='('){			$close_brace=')';		}elseif($open_brace=='['){			$close_brace=']';		}elseif($open_brace=='{'){			$close_brace='}';		}else{			//_echo(e5c($str));			_die('символ открывающей скобки «'.$open_brace.'» не распознан');		}//_echo('$close_brace='.$close_brace);		$context=false;		$deep=1;		$pos=$open_brace_position;		$result=false;		while($pos<mb_strlen($str)){			//просматриваем последовательно все символы, начиная с $open_brace_position, в поисках парной закрывающей скобки			//когда нам попадается кавычка (одинарная или двойная), то мы входим в режим контекста и ожидаем его окончания, не изменяя переменную deep			//когда нам попадается нужная закрывающая скобка, то уменьшаем deep			//когда нам попадается другая открывающая скобка, то увеличиваем deep			//обрываем цикл в случае если deep==0			$pos++;			$symbol=mb_substr($str,$pos,1);			if($context){				if($symbol==$context_symbol){					$context=false;				}			}else{				if($symbol==$close_brace){					$deep--;				}				if($symbol==$open_brace){					$deep++;				}				if($symbol=='"' || $symbol=='\''){					$context=true;					$context_symbol=$symbol;				}			}			if($deep==0){				$result=$pos;				break;			}		}		return $result;	}	function ga($params){		$model_name=isset($this->model_name)?$this->model_name:$this->__name__;		$params=_array_merge(array('classname'=>$model_name),$params);		return ga($params);	}	function gbi($id,$filter=''){		$model_name=isset($this->model_name)?$this->model_name:$this->__name__;		return gbi($model_name,$id,$filter);	}	function fetch($template){		return fetch( sprintf('%s/%s/%s', MODELS_DIR, $this->model_name, $template) );	}	function getModelPath($view='',$domain=''){//возвращает путь к разделу, обрабатываемому привязанной моделью		if($view!=''){			//отыскиваем все страницы с обработчиком $view (фильтрация по языку происходит автоматически), 			//берем первый попавшийся, потому что если таких несколько, 			//то потенциальная ошибка висит на совести администратора сайта			$domain_filter=($domain=='')?'':'and domain='.(int)($domain);			$pages=ga(array(				'classname'=>'structure',				'domain'=>(bool)($domain==''),				'fields'=>'id',				'filter'=>'view="'.e5csql($view).'" '.$domain_filter,//строка фильтра типа 'parent=32'				'_slice'=>'0,1',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)			));			if(count($pages)==1){				$path=getPathById($pages[0]['id'],$domain);			}else{				_die('обработчик «'.$view.'» отсутствует в структуре сайта');			}		}elseif(IS_FIRST===false){			//если $view не передан, то предполагается, что функция вызвана не с первой страницы, 			//а со страницы раздела, который обрабатывается искомой моделью, 			//поэтому путь вытаскивается из градусника			$path='/';			foreach(array_slice($GLOBALS['gradusnik'],1) as $item){$path.=$item['url'].'/';}			$path=DOMAIN_PATH.$path;		}else{			_die('не передан параметр $view в функцию getModelPath()');		}		return $path;	}		function saveDynamicCss($css='',$multidomain_file=false){		$start_string=sprintf("\n/**%s**/\n",$this->__name__);		$end_string="\n/**end**/\n";		// читаем текущий файл и находим часть для замены		$file_content=file2str('/css/','dynamic.css');		$start=mb_strpos($file_content,$start_string);		if($start!==false){			$end=mb_strpos($file_content,$end_string,$start) + mb_strlen($end_string);			if($end===false){				_die(sprintf('найдено начало "%s", но не найдено окончание "%s" в файле %s',$start_string,$end_string,'/css/dynamic.css'));			}			$before=mb_substr($file_content,0,$start);			$after=mb_substr($file_content,$end);		}else{			$before=$file_content;			$end='';		}		$css=$before.$start_string.trim($css).$end_string.$after;		if( USE_SUBDOMAINS===true && !$multidomain_file ){			$file_name=sprintf('dynamic.%s.css', DOMAIN);		}else{			$file_name='dynamic.css';		}		if( file_exists(SITE_DIR.'/media/') ){			fileWrite('/media/css/', $file_name, $css);		}else{			fileWrite('/css/', $file_name, $css);		}	}		// несколько методов, которые могут быть общими	// как правило, методы забирают все поля и кэшируют результаты	// считаю что эта идея неудачна, потому что в примере ниже хорошо бы добавить какое-то условие	// например is_hidden="no", но если реализовать такой функционал, то мы получим дыру в защите	function getAll(){		$model_obj=gmo($this->__name__);		if(!isset($model_obj->__all__)){			$model_obj->__all__=$model_obj->ga(array(				'fields'=>'*',//список полей которые нужно вытащить через запятую 'id,name,body'				'_slice'=>'0',//строка 'n[,m]' возвращает массив элементов начиная с n (заканчивая m, если m передан)			));		}		return $model_obj->__all__;	}}//инклюдим _settings.php для моделей$file_location=MODELS_DIR.'/_settings.php';if(file_exists($file_location)){	include_once($file_location);}else{	_die('Cant load MODELS_DIR/_settings.php');}//если кэширование включено, то добавляем его в $GLOBALS['INSTALLED_APPS'], чтобы в админке появилась закладкаif(USE_CACHE===true){	$GLOBALS['INSTALLED_APPS']['_cache']='[Кэш]';}if( IS_ADMIN===true ){	//инклюдим вспомогательные классы	//model.models.class.php уже загружен в init.php	include(FW_DIR.'/classes/model.modelsfields.class.php');	include(FW_DIR.'/classes/model.users.class.php');	include(FW_DIR.'/classes/model.access.class.php');	include(FW_DIR.'/classes/model.adminlog.class.php');	//и добавляем в $GLOBALS['INSTALLED_APPS'] текстовые названия служебных моделей	$GLOBALS['INSTALLED_APPS']['_users']='[Админы]';	$GLOBALS['INSTALLED_APPS']['_access']='[Доступ]';	$GLOBALS['INSTALLED_APPS']['_models']='[Модели]';	$GLOBALS['INSTALLED_APPS']['_modelsfields']='[Поля]';	$GLOBALS['INSTALLED_APPS']['_adminlog']='[Лог авторизации]';}//здесь же определяем дополнительные классы ModelItemFormHTML, ModelItemFormHTMLClient//которые используется при создании форм с полями моделейclass ModelItemFormHTML{	function ModelItemFormHTML($papa){		$this->papa=$papa;	}	function alert_message($errors_report){		$result='';		if($errors_report!=''){			$result.='<div class="alertBox">'.$errors_report.'</div>';		}		return $result;	}	function getFormFields($model_item_data,$errors_arr){		$result='';		foreach(get_object_vars($this->papa) as $key=>$obj_field){			//перебираем экземпляры класса Field			if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){				//вызываем метод, который возвращает html-код поля				if($obj_field->editable===true || $obj_field->viewable===true){					$error_bool=(isset($errors_arr[$key]))?$errors_arr[$key]:false;					$result.=$obj_field->getFormFieldHTMLCommon($model_item_data,$error_bool);				}			}		}		return $result;	}	function controls($model_item_data){		if(is_array($this->papa->__admin__['controls']) && count($this->papa->__admin__['controls'])>0){			$controls_arr=$this->papa->__admin__['controls'];		}elseif(is_string($this->papa->__admin__['controls'])){			$controls_arr=explode(',',$this->papa->__admin__['controls']);		}else{			$controls_arr=array('save','delete');		}		//проверяем, если в полученном $controls_arr отсутствуют save и delete, то добавляем их		if( !in_array('save',$controls_arr) ){			//добавляем в начало			array_unshift($controls_arr,'save');		}		if( !in_array('delete',$controls_arr) ){			//добавляем в конец			array_push($controls_arr,'delete');		}		$result='';		foreach($controls_arr as $key=>$value){			//пропускаем все кнопки установленные в false			if($value===false){continue;}			//определяем name и value кнопки			$button_text='';			if(is_string($key)){//если ключ строковый, значит кнопка задана парой значений $key=>$value: 'save'=>'Сохранить'				$button_name=$key;				$button_text=(is_string($value))?$value:'';			}else{//ключ числовой, значит кнопка задана одним значением $value: 'save'				$button_name=$value;			}			switch($button_name){				case 'save':					if(false					|| (intval($model_item_data['id'])==0 && $this->papa->userCanAddModelItems())					|| (intval($model_item_data['id'])>0 && $this->papa->userCanEditModelItems())					){						$result.=$this->_getSubmitButton($button_name,defvar('Сохранить',$button_text));					}					break;				case 'save_then_add':					$result.=$this->_getSubmitButton($button_name,defvar('Сохранить и добавить',$button_text));					break;				case 'save_then_exit':					$result.=$this->_getSubmitButton($button_name,defvar('Сохранить и выйти',$button_text));					break;				case 'copy':					if($model_item_data['id']>0){						$result.=$this->_getSubmitButton($button_name,defvar('Скопировать',$button_text));					}					break;				case 'down':					if($model_item_data['id']>0){						$result.=$this->_getSubmitButton($button_name,defvar('&darr;',$button_text),'onclick="A.mil.down(\''.$this->papa->__name__.'\','.$model_item_data['id'].');return false;"');					}					break;				case 'up':					if($model_item_data['id']>0){						$result.=$this->_getSubmitButton($button_name,defvar('&uarr;',$button_text),'onclick="A.mil.up(\''.$this->papa->__name__.'\','.$model_item_data['id'].');return false;"');					}					break;				case 'delete':					if($model_item_data['id']>0 && $this->papa->userCanDeleteModelItems()){						$result.=$this->_getSubmitButton($button_name,defvar('Удалить',$button_text));					}					break;			}			$result.=' ';		}		return $result;	}	function _getSubmitButton($name,$value,$props=''){		$form_items=new FormItems();		switch ($name) {			case 'delete':				$result.=$form_items->submit($value,$name,'class="icon delete"');				break;			case 'save':				$result=$form_items->submit($value,$name,'class="icon save"');				break;			default:				$result=$form_items->submit($value,$name,$props);				break;		}		return $result;	}	function _getAddLink($current_model_item_id){		if($this->papa->userCanAddModelItems() && $current_model_item_id>0){			$result='<a href="'.DOMAIN_PATH.'/admin/'.$this->papa->__name__.'/edit/">добавить</a>';		}		return $result;	}	function getOnsubmit(){		if(isset($this->papa->__admin__['onsubmit'])){			$result='onsubmit="'.$this->papa->__admin__['onsubmit'].'"';		}		if(isset($result)){			return $result;		}	}	function getJsFunctions(){		$obj_model=$this->papa;		$__admin__js=$obj_model->__admin__['js'];		if(isset($__admin__js) && is_string($__admin__js)){			//определяем имя потенциального метода, удаляя с конца "()"			$method=mb_substr($__admin__js,0,-2);			if(is_string($__admin__js) && method_exists($obj_model,$method)){				$js=$obj_model->$method();			}elseif(mb_substr($__admin__js,-3)=='.js'){				$full_path=sprintf('%s/%s/%s', MODELS_DIR, $obj_model->__name__, $__admin__js);				if( file_exists($full_path) ){					$js=file_get_contents($full_path);				}			}else{				_die('неправильное определение $__admin__[\'js\'] в модели '.$obj_model->__name__);			}		}		if( !empty($js) ){			$result=sprintf('				<script type="text/javascript" charset="%s">				<!--					%s				//-->				</script>			', SITE_ENCODING, $js);			return $result;		}	}}class ModelItemFormHTMLClient{	function ModelItemFormHTMLClient($papa,$acc_fields=''){		$this->papa=$papa;		$this->acc_fields=$acc_fields;	}	/**	 * HTML-код полей в порядке перечисленом в $this->acc_fields	 *	 * @param unknown_type $model_item_data	 * @param array $errors_arr	 * @return string	 */	function getFormFields($model_item_data,$errors_arr){		$result = array();		if( is_array($this->acc_fields) && !empty($this->acc_fields) ){			foreach(get_object_vars($this->papa) as $key=>$obj_field){				//перебираем экземпляры класса Field				if(is_object($obj_field) && is_subclass_of($obj_field,'Field')){					if(in_array($key,$this->acc_fields)){						$position_in_result = array_search($key, $this->acc_fields);						//вызываем метод, который возвращает html-код поля						if($obj_field->view_template==''){							$result[$position_in_result].=$obj_field->getFormFieldHTMLCommon($model_item_data,$errors_arr[$key],'editable');						}else{							//получаем название функции							$function=mb_substr($obj_field->view_template,0,-2);							$result[$position_in_result].=$this->papa->$function($obj_field,$model_item_data,$errors_arr[$key]);						}					}				}			}		}		ksort($result);		return implode('',$result);	}}